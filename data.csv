Java,Ruby,Csharp,Scheme,JavaScript,PHP,OCaml,C,Scala,Clojure,lisp,Perl,Haskell,Python
import java.util.*; public class Sum2 {   public static void main(String[] args) {      Scanner in = new Scanner(System.in); // Standard input      System.out.println(in.nextInt() + in.nextInt()); // Standard output   }},puts gets.not_nil!.split.map(&.to_i).sum,using System;using System.Linq; class Program{    static void Main()    {        Console.WriteLine(Console.ReadLine().Split().Select(int.Parse).Sum());    }}," (+ (read-number 1 ""value for A"") (read-number 2 ""value for B"")) ","process.openStdin().on (    'data',    function (line) {        var xs = String(line).match(/^\s*(\d+)\s+(\d+)\s*/)        console.log (            xs ? Number(xs[1]) + Number(xs[2]) : 'usage: <number> <number>'        )        process.exit()    })","fscanf(STDIN, ""%d %d\n"", $a, $b); //Reads 2 numbers from STDINecho ($a + $b) . ""\n"";","Scanf.scanf ""%d %d"" (fun a b -> Printf.printf ""%d\n"" (a + b))","// Standard input-output streams#include <stdio.h>int main(){   int a, b;   scanf(""%d%d"", &a, &b);   printf(""%d\n"", a + b);   return 0;}","println(readLine().split("" "").map(_.toInt).sum)",(println (+ (Integer/parseInt (read-line)) (Integer/parseInt (read-line))))34=>7,(write (+ (read) (read))),"my ($a,$b) = split(' ', scalar(<STDIN>));print ""$a $b "" . ($a + $b) . ""\n"";",main =  print . sum . map read . words =<< getLine,"try: raw_inputexcept: raw_input = input print(sum(map(int, raw_input().split())))"
import java.io.*;import java.util.*; public class SumDif {   StreamTokenizer in;   PrintWriter out;    public static void main(String[] args) throws IOException {      new SumDif().run();   }    private int nextInt() throws IOException {      in.nextToken();      return (int)in.nval;   }    public void run() throws IOException {      in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); // Standard input      out = new PrintWriter(new OutputStreamWriter(System.out)); // Standard output      solve();      out.flush();   }    private void solve() throws IOException {      out.println(nextInt() + nextInt());   }},"if line = gets  puts line.split.map(&.to_i).sumelse  puts ""No input""end","using System; class Program    {        static void Main()        {            start:            string input = Console.ReadLine();            int index = input.IndexOf("" "");            string num1 = input.Substring(0, index);            string num2 = input.Substring(index + 1);            int sum = int.Parse(num1) + int.Parse(num2);            Console.WriteLine(sum.ToString());            goto start;         }    }",(display (+ (read) (read))),"process.stdin.on(""data"", buffer => {  console.log(    (buffer + """").trim().split("" "").map(Number).reduce((a, v) => a + v, 0)  );}); ","$in = fopen(""input.dat"", ""r"");fscanf($in, ""%d %d\n"", $a, $b); //Reads 2 numbers from file $infclose($in); $out = fopen(""output.dat"", ""w"");fwrite($out, ($a + $b) . ""\n"");fclose($out);"," open Num let fib =  let rec fib_aux f0 f1 = function    | 0 -> f0    | 1 -> f1    | n -> fib_aux f1 (f1 +/ f0) (n - 1)  in  fib_aux (num_of_int 0) (num_of_int 1) ;; let create_fibo_string = function n -> string_of_num (fib n) ;;let rec range i j = if i > j then [] else i :: (range (i + 1) j) let n_max = 1000 ;; let numbers = range 1 n_max in  let get_first_digit = function s -> Char.escaped (String.get s 0) in    let first_digits = List.map get_first_digit (List.map create_fibo_string numbers) in  let data = Array.create 9 0 in    let fill_data vec = function n -> vec.(n - 1) <- vec.(n - 1) + 1 in    List.iter (fill_data data) (List.map int_of_string first_digits) ;    Printf.printf ""\nFrequency of the first digits in the Fibonacci sequence:\n"" ;    Array.iter (Printf.printf ""%f "")      (Array.map (fun x -> (float x) /. float (n_max)) data) ; let xvalues = range 1 9 in  let benfords_law = function x -> log10 (1.0 +. 1.0 /. float (x)) in    Printf.printf ""\nPrediction of Benford's law:\n "" ;    List.iter (Printf.printf ""%f "") (List.map benfords_law xvalues) ;    Printf.printf ""\n"" ;; ","// Input file: input.txt// Output file: output.txt#include <stdio.h>int main(){   freopen(""input.txt"", ""rt"", stdin);   freopen(""output.txt"", ""wt"", stdout);   int a, b;   scanf(""%d%d"", &a, &b);   printf(""%d\n"", a + b);   return 0;}",val s = new java.util.Scanner(System.in)val sum = s.nextInt() + s.nextInt()println(sum),"(eval (read-string (str ""(+ "" (read-line) "" )"") ))3 36",(main  (decl int a)  (decl int b)  (>> std::cin a b)  (prn (+ a b))),"#!/usr/bin/perluse strict ;use warnings ;use POSIX qw( log10 ) ; my @fibonacci = ( 0 , 1  ) ;while ( @fibonacci != 1000 ) {   push @fibonacci , $fibonacci[ -1 ] + $fibonacci[ -2 ] ;}my @actuals ;my @expected ;for my $i( 1..9 ) {   my $sum = 0 ;   map { $sum++ if $_ =~ /\A$i/ } @fibonacci ;   push @actuals , $sum / 1000  ;   push @expected , log10( 1 + 1/$i ) ;}print ""         Observed         Expected\n"" ;for my $i( 1..9 ) {   print ""$i : "" ;   my $result = sprintf ( ""%.2f"" , 100 * $actuals[ $i - 1 ] ) ;   printf ""%11s %%"" , $result ;   $result = sprintf ( ""%.2f"" , 100 * $expected[ $i - 1 ] ) ;   printf ""%15s %%\n"" , $result ;}","import qualified Data.Map as M type NodeID = Maybe Rationaldata Node a = Node   {vNode :: a,    pNode, nNode :: NodeID}type DLList a = M.Map Rational (Node a) empty = M.empty singleton a = M.singleton 0 $ Node a Nothing Nothing fcons :: a -> DLList a -> DLList afcons a list | M.null list = singleton a             | otherwise   = M.insert newid new $                             M.insert firstid changed list  where (firstid, Node firstval _ secondid) = M.findMin list        newid = firstid - 1        new     = Node a        Nothing      (Just firstid)        changed = Node firstval (Just newid) secondid rcons :: a -> DLList a -> DLList arcons a list | M.null list = singleton a             | otherwise   = M.insert lastid changed $                             M.insert newid new list  where (lastid, Node lastval penultimateid _) = M.findMax list        newid = lastid + 1        changed = Node lastval penultimateid (Just newid)        new     = Node a       (Just lastid) Nothing mcons :: a -> Node a -> Node a -> DLList a -> DLList amcons a n1 n2 = M.insert n1id left .    M.insert midid mid . M.insert n2id right  where Node n1val farleftid   (Just n2id) = n1        Node n2val (Just n1id) farrightid  = n2        midid = (n1id + n2id) / 2   -- Hence the use of Rationals.        mid = Node a (Just n1id) (Just n2id)        left  = Node n1val farleftid    (Just midid)        right = Node n2val (Just midid) farrightid firstNode :: DLList a -> Node afirstNode = snd . M.findMin lastNode :: DLList a -> Node alastNode = snd . M.findMax nextNode :: DLList a -> Node a -> Maybe (Node a)nextNode l n = nNode n >>= flip M.lookup l prevNode :: DLList a -> Node a -> Maybe (Node a)prevNode l n = pNode n >>= flip M.lookup l fromList = foldr fcons empty toList = map vNode . M.elems","import sys for line in sys.stdin:    print(sum(map(int, line.split())))"
"import java.io.*;  public class AplusB {	public static void main(String[] args) {		try {			StreamTokenizer in = new StreamTokenizer(new FileReader(""input.txt""));			in.nextToken();			int a = (int) in.nval;			in.nextToken();			int b = (int) in.nval;			FileWriter outFile = new FileWriter(""output.txt"");			outFile.write(Integer.toString(a + b));			outFile.close();		}		catch (IOException e) {			System.out.println(""IO error"");		}	}}",puts gets.split.map(&:to_i).inject(:+), public static ulong Fib(uint n) {    return (n < 2)? n : Fib(n - 1) + Fib(n - 2);} , (lib 'plot) (define *red* (rgb 1 0 0))(define (ulam n nmax) (if ( prime? n) *red* (gray (// n nmax))))(plot-spiral ulam 1000) ;; range [0...1000] ,"function fib(n) {  return function(n,a,b) {    return n>0 ? arguments.callee(n-1,b,a+b) : a;  }(n,0,1);}","function fibIter($n) {    if ($n < 2) {        return $n;    }    $fibPrev = 0;    $fib = 1;    foreach (range(1, $n-1) as $i) {        list($fibPrev, $fib) = array($fib, $fib + $fibPrev);    }    return $fib;}","fun fib         (0, x1, x2) = x2      | (n, x1, x2) = fib (n-1, x2, x1+x2)      | n = fib (n, 0, 1)"," #include <stdio.h>#include <stdlib.h>int main(int argc, char **argv) //not sure if argv counts as input stream... certainly it is brought here via input stream.{   printf(""%d\n"", atoi(*(argv+1)) + atoi(*(argv+2)));   return 0;} ","println(readLine().split("" "").filter(_.length>0).map(_.toInt).sum)",(println (+ (read) (read)))3 47,"(defstruct dlist head tail)(defstruct dlink content prev next) (defun insert-between (dlist before after data)  ""Insert a fresh link containing DATA after existing link BEFORE if not nil and before existing link AFTER if not nil""  (let ((new-link (make-dlink :content data :prev before :next after)))    (if (null before)        (setf (dlist-head dlist) new-link)        (setf (dlink-next before) new-link))    (if (null after)        (setf (dlist-tail dlist) new-link)        (setf (dlink-prev after) new-link))    new-link)) (defun insert-before (dlist dlink data)  ""Insert a fresh link containing DATA before existing link DLINK""  (insert-between dlist (dlink-prev dlink) dlink data)) (defun insert-after (dlist dlink data)  ""Insert a fresh link containing DATA after existing link DLINK""  (insert-between dlist dlink (dlink-next dlink) data)) (defun insert-head (dlist data)  ""Insert a fresh link containing DATA at the head of DLIST""  (insert-between dlist nil (dlist-head dlist) data)) (defun insert-tail (dlist data)  ""Insert a fresh link containing DATA at the tail of DLIST""  (insert-between dlist (dlist-tail dlist) nil data)) (defun remove-link (dlist dlink)  ""Remove link DLINK from DLIST and return its content""  (let ((before (dlink-prev dlink))        (after (dlink-next dlink)))    (if (null before)        (setf (dlist-head dlist) after)        (setf (dlink-next before) after))    (if (null after)        (setf (dlist-tail dlist) before)        (setf (dlink-prev after) before)))) (defun dlist-elements (dlist)  ""Returns the elements of DLIST as a list""  (labels ((extract-values (dlink acc)             (if (null dlink)                 acc                 (extract-values (dlink-next dlink) (cons (dlink-content dlink) acc)))))    (reverse (extract-values (dlist-head dlist) nil))))","use ntheory qw/is_prime/;use Imager; my $n = shift || 512;my $start = shift || 1;my $file = ""ulam.png""; sub cell {  my($n, $x, $y, $start) = @_;  $y -= $n>>1;  $x -= ($n-1)>>1;  my $l = 2*(abs($x) > abs($y) ? abs($x) : abs($y));  my $d = ($y > $x)  ?  $l*3 + $x + $y  : $l-$x-$y;  ($l-1)**2 + $d + $start - 1;} my $black = Imager::Color->new('#000000');my $white = Imager::Color->new('#FFFFFF');my $img = Imager->new(xsize => $n, ysize => $n, channels => 1);$img->box(filled=>1, color=>$white); for my $y (0 .. $n-1) {  for my $x (0 .. $n-1) {    my $v = cell($n, $x, $y, $start);    $img->setpixel(x => $x, y => $y, color => $black) if is_prime($v);  }} $img->write(file => $file) or die ""Cannot write $file: "", $img->errstr, ""\n"";",main = putStrLn $ toList l  where l = mcons 'M' n1 n2 x        x = rcons 'Z' $ fcons 'a' $ fcons 'q' $ singleton 'w'        n1 = firstNode x        Just n2 = nextNode x n1,"from __future__ import divisionfrom itertools import islice, countfrom collections import Counterfrom math import log10from random import randint expected = [log10(1+1/d) for d in range(1,10)] def fib():    a,b = 1,1    while True:        yield a        a,b = b,a+b # powers of 3 as a test sequencedef power_of_threes():    return (3**k for k in count(0)) def heads(s):    for a in s: yield int(str(a)[0]) def show_dist(title, s):    c = Counter(s)    size = sum(c.values())    res = [c[d]/size for d in range(1,10)]     print(""\n%s Benfords deviation"" % title)    for r, e in zip(res, expected):        print(""%5.1f%% %5.1f%%  %5.1f%%"" % (r*100., e*100., abs(r - e)*100.)) def rand1000():    while True: yield randint(1,9999) if __name__ == '__main__':    show_dist(""fibbed"", islice(heads(fib()), 1000))    show_dist(""threes"", islice(heads(power_of_threes()), 1000))     # just to show that not all kind-of-random sets behave like that    show_dist(""random"", islice(heads(rand1000()), 10000))"
"import java.math.BigInteger; public class Benford {    private static interface NumberGenerator {        BigInteger[] getNumbers();    }     private static class FibonacciGenerator implements NumberGenerator {        public BigInteger[] getNumbers() {            final BigInteger[] fib = new BigInteger[ 1000 ];            fib[ 0 ] = fib[ 1 ] = BigInteger.ONE;            for ( int i = 2; i < fib.length; i++ )                fib[ i ] = fib[ i - 2 ].add( fib[ i - 1 ] );            return fib;        }    }     private final int[] firstDigits = new int[ 9 ];    private final int   count;     private Benford( final NumberGenerator ng ) {        final BigInteger[] numbers = ng.getNumbers();        count = numbers.length;        for ( final BigInteger number : numbers )            firstDigits[ Integer.valueOf( number.toString().substring( 0, 1 ) ) - 1 ]++;    }     public String toString() {        final StringBuilder result = new StringBuilder();        for ( int i = 0; i < firstDigits.length; i++ )            result.append( i + 1 )                .append( '\t' ).append( firstDigits[ i ] / ( double )count )                .append( '\t' ).append( Math.log10( 1 + 1d / ( i + 1 ) ) )                .append( '\n' );        return result.toString();    }     public static void main( final String[] args ) {        System.out.println( new Benford( new FibonacciGenerator() ) );    }}",say STDIN.readline.words.map{.to_i}.sum," public static ulong Fib(uint n) {    return Fib(0, 1, n);} private static ulong Fib(ulong a, ulong b, uint n) {    return (n < 1)? a :(n == 1)?  b : Fib(b, a + b, n - 1);} ", (define (fib n)     (if (< n 2) n     (+ (fib (- n 2)) (fib (1- n))))) (remember 'fib #(0 1)) (for ((i 12)) (write (fib i)))0 1 1 2 3 5 8 13 21 34 55 89  ," function fib(n) {  var a = 0, b = 1, t;  while (n-- > 0) {    t = a;    a = b;    b += t;    console.log(a);  }  return a;} ",function fibRec($n) {    return $n < 2 ? $n : fibRec($n-1) + fibRec($n-2);},let fib_iter n =  if n < 2 then    n  else let fib_prev = ref 1  and fib = ref 1 in    for num = 2 to n - 1 do      let temp = !fib in        fib := !fib + !fib_prev;        fib_prev := temp    done;    !fib,"void main() {    string a, b;    scan(gets(stdin), ""%d %d"", &a, &b);     puts(((int)a + (int)b));}","package benford import java.math.BigInteger interface NumberGenerator {    val numbers: Array<BigInteger>} class Benford(val ng: NumberGenerator) {    override fun toString() = str     private val firstDigits = IntArray(9)    private val count= ng.numbers.size    private val str: String     init {        for (n in ng.numbers)            firstDigits[n.toString().substring(0, 1).toInt() - 1]++        val result = StringBuilder()        for (i in firstDigits.indices) {            result.append(i + 1).append('\t').append(firstDigits[i] / count.toDouble())            result.append('\t').append(Math.log10(1 + 1.0 / (i + 1))).append('\n')        }        str = result.toString()    }} object FibonacciGenerator : NumberGenerator {    override val numbers: Array<BigInteger> by lazy {        val fib = Array<BigInteger>(1000, { BigInteger.ONE })        for (i in 2..fib.size - 1)            fib[i] = fib[i - 2].add(fib[i - 1])        fib    }} fun main(a: Array<String>) = println(Benford(FibonacciGenerator))","(let [ints (map #(Integer/parseInt %) (clojure.string/split (read-line) #""\s"") )]   (println (reduce + ints)))3 4=>7",(let ((dlist (make-dlist)))  (insert-head dlist 1)  (insert-tail dlist 4)  (insert-after dlist (dlist-head dlist) 2)  (let* ((next-to-last (insert-before dlist (dlist-tail dlist) 3))         (bad-link (insert-before dlist next-to-last 42)))    (remove-link dlist bad-link))  (print (dlist-elements dlist))),"sub fib_iter {  my $n = shift;  use bigint try => ""GMP,Pari"";  my ($v2,$v1) = (-1,1);  ($v2,$v1) = ($v1,$v2+$v1) for 0..$n;  $v1;}","import qualified Data.Map as Mimport Data.Char (digitToInt) fstdigit :: Integer -> Intfstdigit = digitToInt . head . show n = 1000::Intfibs = 1:1:zipWith (+) fibs (tail fibs)fibdata = map fstdigit $ take n fibsfreqs = M.fromListWith (+) $ zip fibdata (repeat 1) tab ::  [(Int, Double, Double)]tab = [(d,        (fromIntegral (M.findWithDefault 0 d freqs) /(fromIntegral n) ),        logBase 10.0 $ 1 + 1/(fromIntegral d) ) | d<-[1..9]] main = print tab","# coding=UTF-8from __future__ import print_function, divisionfrom math import sqrt def cell(n, x, y, start=1):    d, y, x = 0, y - n//2, x - (n - 1)//2    l = 2*max(abs(x), abs(y))    d = (l*3 + x + y) if y >= x else (l - x - y)    return (l - 1)**2 + d + start - 1 def show_spiral(n, symbol='# ', start=1, space=None):    top = start + n*n + 1    is_prime = [False,False,True] + [True,False]*(top//2)    for x in range(3, 1 + int(sqrt(top))):        if not is_prime[x]: continue        for i in range(x*x, top, x*2):            is_prime[i] = False     cell_str = lambda x: f(x) if is_prime[x] else space    f = lambda _: symbol # how to show prime cells     if space == None: space = ' '*len(symbol)     if not len(symbol): # print numbers instead        max_str = len(str(n*n + start - 1))        if space == None: space = '.'*max_str + ' '        f = lambda x: ('%' + str(max_str) + 'd ')%x     for y in range(n):        print(''.join(cell_str(v) for v in [cell(n, x, y, start) for x in range(n)]))    print() show_spiral(10, symbol=u'♞', space=u'♘') # black are the primesshow_spiral(9, symbol='', space=' - ')# for filling giant terminals#show_spiral(1001, symbol='*', start=42)"
"import java.awt.*;import javax.swing.*; public class LargeUlamSpiral extends JPanel {     public LargeUlamSpiral() {        setPreferredSize(new Dimension(605, 605));        setBackground(Color.white);    }     private boolean isPrime(int n) {        if (n <= 2 || n % 2 == 0)            return n == 2;        for (int i = 3; i * i <= n; i += 2)            if (n % i == 0)                return false;        return true;    }     @Override    public void paintComponent(Graphics gg) {        super.paintComponent(gg);        Graphics2D g = (Graphics2D) gg;        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,                RenderingHints.VALUE_ANTIALIAS_ON);         g.setColor(getForeground());         double angle = 0.0;        int x = 300, y = 300, dx = 1, dy = 0;         for (int i = 1, step = 1, turn = 1; i < 40_000; i++) {             if (isPrime(i))                g.fillRect(x, y, 2, 2);             x += dx * 3;            y += dy * 3;             if (i == turn) {                 angle += 90.0;                 if ((dx == 0 && dy == -1) || (dx == 0 && dy == 1))                    step++;                 turn += step;                 dx = (int) Math.cos(Math.toRadians(angle));                dy = (int) Math.sin(Math.toRadians(-angle));            }        }    }     public static void main(String[] args) {        SwingUtilities.invokeLater(() -> {            JFrame f = new JFrame();            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);            f.setTitle(""Large Ulam Spiral"");            f.setResizable(false);            f.add(new LargeUlamSpiral(), BorderLayout.CENTER);            f.pack();            f.setLocationRelativeTo(null);            f.setVisible(true);        });    }}",say read(String).words»to_i»()«+», public static ulong Fib(uint x) {    if (x == 0) return 0;     ulong prev = 0;    ulong next = 1;    for (int i = 1; i < x; i++)    {        ulong sum = prev + next;        prev = next;        next = sum;    }    return next;} ,(define (fib-iter n)  (do ((num 2 (+ num 1))       (fib-prev 1 fib)       (fib 1 (+ fib fib-prev)))      ((>= num n) fib))),"var fib = (function(cache){    return cache = cache || {}, function(n){        if (cache[n]) return cache[n];        else return cache[n] = n == 0 ? 0 : n < 0 ? -fib(-n)            : n <= 2 ? 1 : fib(n-2) + fib(n-1);    };})(); "," <html><head><title>n x n Queen solving program</title></head><body><?phpecho ""<h1>n x n Queen solving program</h1>""; //Get the size of the board$boardX = $_POST['boardX'];$boardY = $_POST['boardX']; // Function to rotate a board 90 degreesfunction rotateBoard($p, $boardX) {$a=0;while ($a < count($p)) {	$b = strlen(decbin($p[$a]))-1;	$tmp[$b] = 1 << ($boardX - $a - 1);	++$a;	}ksort($tmp);return $tmp;} // This function will find rotations of a solutionfunction findRotation($p, $boardX,$solutions){$tmp = rotateBoard($p,$boardX);// Rotated 90if (in_array($tmp,$solutions)) {}else {$solutions[] = $tmp;} $tmp = rotateBoard($tmp,$boardX);// Rotated 180if (in_array($tmp,$solutions)){}else {$solutions[] = $tmp;} $tmp = rotateBoard($tmp,$boardX);// Rotated 270if (in_array($tmp,$solutions)){}else {$solutions[] = $tmp;} // Reflected$tmp = array_reverse($p);if (in_array($tmp,$solutions)){}else {$solutions[] = $tmp;} $tmp = rotateBoard($tmp,$boardX);// Reflected and Rotated 90if (in_array($tmp,$solutions)){}else {$solutions[] = $tmp;} $tmp = rotateBoard($tmp,$boardX);// Reflected and Rotated 180if (in_array($tmp,$solutions)){}else {$solutions[] = $tmp;} $tmp = rotateBoard($tmp,$boardX);// Reflected and Rotated 270if (in_array($tmp,$solutions)){}else {$solutions[] = $tmp;}return $solutions;} // This is a function which will render the boardfunction renderBoard($p,$boardX) {$img = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAABmJLR0QA/wD/AP+gvaeTAAAGFUlEQVRYhe2YXWibVRjHf2lqP9JmaRi4YW1IalY3rbZsaddMgsquBm676b6KyNDhLiaUeSEMvPNCcNuNyJjgLiboCnoxKFlv6lcHy7AtMhhaWTVZWhisjDTEtEuW5PHiPWnfvH2TvNk6vekfDm/O+Z/zPP/3PM/5eAMb2MAG/nfYn4LNVuBj4ENgB/Ar8Ogp+KkJbwLfqvKGgbMBPwKiK+Oq3aqNdcebQEEnqAC8ruO7KBVcLF012KiKuhpFv0/prNlU239qw0x0pdBJFXt30NJDjx9Uu1Ub1TSYdq4UutcNfI61oW0Bflb8T6quRzUbNafPFdbm4zcmTucV91kZO18o/osy/GeKnzcRVFWDMT2shO4X4IL6/UqZPv2GpxHFcReUvVo1lMAYunKh+UTxeeB5A/cMkFF8RtX1eF6NE2XHTIN+ltekoHGmf0HLqe9V3Qb8ZWK4Xjf+HQP3KtCgfjeouh7v6PzWsxZ6f98De1kbjbIovumoCfcp2gzkgb8p3cJOUjpTJ3WcTfXPq/Gfmtge1Y01RaV9+jv1fAsYMnAu3XgfENJxfUoU6tmn40Kqf9Gvi1IMKX96/zWJnlLP4i7wrIEvzkQeeFfXvltnt07Vi3iX1RcyzuSzrO46ev81YS+rYcqjbUVFfIl2CSryS4ATcKCF3biQHIpf0rU/UnaKuMLqAhXlv2a4Dc4FOKi4bwyiBTgBvGYyRlT7CUPbI1b334MmY9zlhFVKjwQQ09ULaDNTNKYPbx54j9L81aNP8XldW3G8W9kt6LiY8m8Ksy1Hj0mgA+3eXYeWd2eBRkpf2A4MoO3JOYPdHPA2sMtgu07ZOavsFnegvPL72PiItWEroB0axtwtmPStxOeUHbNxH1USVe1qOm3SVkA7NIwX+1phU3YKJpyZX8swW4y1FOMsVotG1UUI1mbrH9ZeL/UQi3b0C7dS/2W0LbIsqi1E0K6PL5oRdrudHTt22Px+Pz6fD6/XS3NzM21tbSt9FhcXWVpaIhqN2mKxGLOzs8zMzJDP581MQukHw2OLPgt8VRQZDAbZv38/wWCQnTt30tKyGoRUKsWDBw/IZrOkUimcTicNDQ1s3rwZp9O50i+dTjM9Pc2NGzcIh8NEIhH9S3xuQVNV2IArp06dkoWFBRERefjwoUxMTMi5c+fk8OHD0tPTIy6Xq2Keulwu6enpkSNHjsj58+dlYmJCMpmMiIgsLCzIxYsXBe1UfNIFvoL6M2fO/Hn58uXC4OCgtLa2PsniXClOp1MGBwfl0qVLhdOnT/+BtcjX9FYe4Pe+vj6Hy+Vat9lIJpMyOTm5BLwExNfL7gpCodAFeQoIhUIXqntfhaVwFHH9+nXp7+8vuFyuWv8vKYtkMlmYnJwse+F/Urzi9/ulqanJ6gFhqTQ1NeW7u7sF6Fx3xd3d3bdERNLptITDYRkeHpZgMCgOh6MmkQ6HQ/bs2SPDw8MSDoclnU6LiMju3buvlHG9BlYX1F5gfGhoiEAgwL59+9i+fTsAuVyOWCxGPB4nHo+TSCTIZrMkEgncbjeNjY243W46OjrweDx4vV7q67WsnJmZYWxsjGvXrjE+Pm5Zj1XRX3d2dg7Nz8/bs9ksAFu2bGHXrl0EAgG2bduG1+vF4/HgdDrZtGkTdrudXC5HKpUilUpx9+5dYrEYd+7cYXp6mqmpKe7fvw9AQ0MDXV1d3L59+2Xgd4uaKqO3t/cnEZFkMikjIyNy9OhRaW9vf6Jcbm9vl2PHjsnIyIgkk0kRETl06NAHVvRYnenA8ePHJ4PBIAcOHGDr1q0AxONxbt68yezsLNFolLm5ORKJBMvLy6TTaVpaWmhubl5JD5/Ph9/vZ2BgAI/HA8C9e/cYHR3l6tWry2NjY88Bi+slGqAHOFVXVxfq7e3tGhgYqAsGgwQCAfH5fLbGxsaqBjKZDNFoVKampmyRSIRIJFK4devWn4VC4TpwEfjNipDHPdlagADaf3X9NpvthY6Ojk6Px+Mq3vLsdjv5fJ7FxUWWl5eJx+OJubm5mIjMon1O/Yr2N0G6VufrdhwrtAJtaN9+bWihzqB9pNYsbgMbeAz8C3N/JQD4H5KCAAAAAElFTkSuQmCC';echo ""<table border=1 cellspacing=0 style='text-align:center;display:inline'>"";for ($y = 0; $y < $boardX; ++$y) {	echo '<tr>';	for ($x = 0; $x < $boardX; ++$x){	if (($x+$y) & 1) { $cellCol = '#9C661F';}	else {$cellCol = '#FCE6C9';} 	if ($p[$y] == 1 << $x) { echo ""<td bgcolor="".$cellCol.""><img width=30 height=30 src='"".$img.""'></td>"";}	else { echo ""<td bgcolor="".$cellCol.""> </td>"";}	}	echo '<tr>';}echo '<tr></tr></table>&nbsp'; } //This function allows me to generate the next order of rows.function pc_next_permutation($p) {$size = count($p) - 1;// slide down the array looking for where we're smaller than the next guy  for ($i = $size - 1; $p[$i] >= $p[$i+1]; --$i) { }  // if this doesn't occur, we've finished our permutations // the array is reversed: (1, 2, 3, 4) => (4, 3, 2, 1) if ($i == -1) { return false; }  // slide down the array looking for a bigger number than what we found before for ($j = $size; $p[$j] <= $p[$i]; --$j) { } // swap them $tmp = $p[$i]; $p[$i] = $p[$j]; $p[$j] = $tmp; // now reverse the elements in between by swapping the ends for (++$i, $j = $size; $i < $j; ++$i, --$j) { $tmp = $p[$i]; $p[$i] = $p[$j]; $p[$j] = $tmp; } return $p; }  //This function needs to check the current state to see if there are any function checkBoard($p,$boardX) {	$a = 0; //this is the row being checked	while ($a < count($p)) { 		$b = 1;		while ($b < ($boardX - $a)){		$x = $p[$a+$b] << $b;		$y = $p[$a+$b] >> $b;		if ($p[$a] == $x | $p[$a] == $y) { return false;}				++$b;		}	++$a; 	}	return true;}  if (isset($_POST['process']) && isset($_POST['boardX'])){//Within here is the code that needs to be run if process is clicked.  //First I need to create the different possible rowsfor ($x = 0; $x < $boardX; ++$x){	$row[$x] = 1 << $x;	} //Now I need to create all the possible orders of rows, will be equal to [boardY]!$solcount = 0;$solutions = array();while ($row != false) {	if (checkBoard($row,$boardX)){	if(!in_array($row,$solutions)){		$solutions[] = $row;			renderBoard($row,$boardX);			$solutions = findRotation($row,$boardX,$solutions);			++$solcount;		} 	}	$row = pc_next_permutation($row);	 	}echo ""<br><br>&nbsp&nbsp&nbsp&nbspRows/Columns: "".$boardX.""<br>&nbsp&nbsp&nbsp&nbspUnique Solutions: "".$solcount.""<br>&nbsp&nbsp&nbsp&nbspTotal Solutions: "".count($solutions).""  - Note: This includes symmetrical solutions<br>"";//print_r($solutions);} //This code collects the starting parametersecho <<<_END<form name=""input"" action=""queens.php"" method=""post"">&nbsp&nbsp&nbsp&nbspNumber of columns/rows <select name=""boardX"" /><option value=""1"">One</option><option value=""2"">Two</option><option value=""3"">Three</option><option value=""4"" >Four</option><option value=""5"">Five</option><option value=""6"">Six</option><option value=""7"">Seven</option><option value=""8"" selected=""selected"">Eight</option><option value=""9"">Nine</option><option value=""10"">Ten</option></select>    <input type=""hidden"" name=""process"" value=""yes"" />&nbsp<input type=""submit"" value=""Process"" /></form> _END; ?></body></html>",let rec fib_rec n =  if n < 2 then    n  else    fib_rec (n - 1) + fib_rec (n - 2) (* with support for negatives *)let rec fib = function     0 -> 0  | 1 -> 1  | n -> if n > 0 then fib (n-1) + fib (n-2)         else fib (n+2) - fib (n+1) ,"/* double linked list */#include <stdio.h>#include <stdlib.h> struct List {   struct MNode *head;   struct MNode *tail;   struct MNode *tail_pred;}; struct MNode {   struct MNode *succ;   struct MNode *pred;}; typedef struct MNode *NODE;typedef struct List *LIST; /*** LIST l = newList()** create (alloc space for) and initialize a list*/LIST newList(void); /*** int isEmpty(LIST l)** test if a list is empty*/int isEmpty(LIST); /*** NODE n = getTail(LIST l)** get the tail node of the list, without removing it*/NODE getTail(LIST); /*** NODE n = getHead(LIST l)** get the head node of the list, without removing it*/NODE getHead(LIST); /*** NODE rn = addTail(LIST l, NODE n)** add the node n to the tail of the list l, and return it (rn==n)*/NODE addTail(LIST, NODE); /*** NODE rn = addHead(LIST l, NODE n)** add the node n to the head of the list l, and return it (rn==n)*/NODE addHead(LIST, NODE); /*** NODE n = remHead(LIST l)** remove the head node of the list and return it*/NODE remHead(LIST); /*** NODE n = remTail(LIST l)** remove the tail node of the list and return it*/NODE remTail(LIST); /*** NODE rn = insertAfter(LIST l, NODE r, NODE n)** insert the node n after the node r, in the list l; return n (rn==n)*/NODE insertAfter(LIST, NODE, NODE); /*** NODE rn = removeNode(LIST l, NODE n)** remove the node n (that must be in the list l) from the list and return it (rn==n)*/NODE removeNode(LIST, NODE);  LIST newList(void){    LIST tl = malloc(sizeof(struct List));    if ( tl != NULL )    {       tl->tail_pred = (NODE)&tl->head;       tl->tail = NULL;       tl->head = (NODE)&tl->tail;       return tl;    }    return NULL;} int isEmpty(LIST l){   return (l->head->succ == 0);} NODE getHead(LIST l){  return l->head;} NODE getTail(LIST l){  return l->tail_pred;}  NODE addTail(LIST l, NODE n){    n->succ = (NODE)&l->tail;    n->pred = l->tail_pred;    l->tail_pred->succ = n;    l->tail_pred = n;    return n;} NODE addHead(LIST l, NODE n){    n->succ = l->head;    n->pred = (NODE)&l->head;    l->head->pred = n;    l->head = n;    return n;} NODE remHead(LIST l){   NODE h;   h = l->head;   l->head = l->head->succ;   l->head->pred = (NODE)&l->head;   return h;} NODE remTail(LIST l){   NODE t;   t = l->tail_pred;   l->tail_pred = l->tail_pred->pred;   l->tail_pred->succ = (NODE)&l->tail;   return t;} NODE insertAfter(LIST l, NODE r, NODE n){   n->pred = r; n->succ = r->succ;   n->succ->pred = n; r->succ = n;   return n;} NODE removeNode(LIST l, NODE n){   n->pred->succ = n->succ;   n->succ->pred = n->pred;   return n;}","// Fibonacci Sequence (begining with 1,1): 1 1 2 3 5 8 13 21 34 55 ...val fibs : Stream[BigInt] = { def series(i:BigInt,j:BigInt):Stream[BigInt] = i #:: series(j, i+j); series(1,0).tail.tail }  /** * Given a numeric sequence, return the distribution of the most-signicant-digit  * as expected by Benford's Law and then by actual distribution. */def benford[N:Numeric]( data:Seq[N] ) : Map[Int,(Double,Double)] = {   import scala.math._   val maxSize = 10000000  // An arbitrary size to avoid problems with endless streams   val size = (data.take(maxSize)).size.toDouble   val distribution = data.take(maxSize).groupBy(_.toString.head.toString.toInt).map{ case (d,l) => (d -> l.size) }   (for( i <- (1 to 9) ) yield { (i -> (log10(1D + 1D / i), (distribution(i) / size))) }).toMap} {  println( ""Fibonacci Sequence (size=1000): 1 1 2 3 5 8 13 21 34 55 ...\n"" )  println( ""%9s %9s %9s"".format( ""Actual"", ""Expected"", ""Deviation"" ) )   benford( fibs.take(1000) ).toList.sorted foreach {     case (k, v) => println( ""%d: %5.2f%% | %5.2f%% | %5.4f%%"".format(k,v._2*100,v._1*100,math.abs(v._2-v._1)*100) )   }}","(println (reduce + (map #(Integer/parseInt %) (clojure.string/split (read-line) #""\s"") ))) 3 4=>7","(defun calculate-distribution (numbers)  ""Return the frequency distribution of the most significant nonzero    digits in the given list of numbers. The first element of the list    is the frequency for digit 1, the second for digit 2, and so on.""   (defun nonzero-digit-p (c)    ""Check whether the character is a nonzero digit""    (and (digit-char-p c) (char/= c #\0)))   (defun first-digit (n)    ""Return the most significant nonzero digit of the number or NIL if     there is none.""    (let* ((s (write-to-string n))           (c (find-if #'nonzero-digit-p s)))      (when c        (digit-char-p c))))   (let ((tally (make-array 9 :element-type 'integer :initial-element 0)))    (loop for n in numbers           for digit = (first-digit n)          when digit           do (incf (aref tally (1- digit))))    (loop with total = (length numbers)          for digit-count across tally          collect (/ digit-count total)))) (defun calculate-benford-distribution ()  ""Return the frequency distribution according to Benford's law.   The first element of the list is the probability for digit 1, the second    element the probability for digit 2, and so on.""  (loop for i from 1 to 9        collect (log (1+ (/ i)) 10))) (defun benford (numbers)  ""Print a table of the actual and expected distributions for the given   list of numbers.""  (let ((actual-distribution (calculate-distribution numbers))        (expected-distribution (calculate-benford-distribution)))    (write-line ""digit actual expected"")    (format T ""~:{~3D~9,3F~8,3F~%~}""             (map 'list #'list '(1 2 3 4 5 6 7 8 9)                              actual-distribution                              expected-distribution))))",sub fibRec {    my $n = shift;    $n < 2 ? $n : fibRec($n - 1) + fibRec($n - 2);},"import Data.Listimport Data.Numbers.Primes -- Add a row to existing spiral by rotating right and adding new row to top-- Results in spirals that turn in the wrong direction and must later be fixed.addRow :: [[Int]] -> [[Int]]addRow spiral = let height = length spiral                    width = length $ head spiral                    row = [height*width+1.. height*width+height]                in row : reverse (transpose spiral) -- Generate spiral by adding two rows (vertical & horizontal) to smaller spiralpreSpiral :: Int => [[Int]]preSpiral 1 = [[1]]preSpiral n = addRow $ addRow $ preSpiral (n-1) -- Make ulamSpiral; fix spiral direction by flipping preSpiral.ulamSpiral :: Int => [[Int]]ulamSpiral n | odd n = reverse $ preSpiral n             | otherwise =  map reverse $ preSpiral n -- Make and print ulamSpiral:      -- Use converter to change numbers to strings.    -- Change empty strings to dashes.      -- Pad strings out to correct length before printing. prettyPrintSpiral :: Int -> (Int -> String) -> IO ()prettyPrintSpiral n converter =         let stringSpiral = map (map converter) (ulamSpiral n)             maxLen = maximum (map (maximum.map length) stringSpiral)            dashFunc s = if s == """" then replicate maxLen '-' else s            padFunc s = replicate (maxLen - length s)  ' ' ++ s            padded = map (padFunc.dashFunc)            showRow = unwords.padded        in mapM_ (putStrLn.showRow) stringSpiral  main :: IO ()main = do           -- Display with converter that shows primes as Strings.          prettyPrintSpiral 10 (\n -> if isPrime n then show n else """")           putStrLn """"           -- Display with converter that shows primes as single dots.          prettyPrintSpiral 60 (\n -> if isPrime n then ""*"" else "" "") ","from math import * def analytic_fibonacci(n):  sqrt_5 = sqrt(5);  p = (1 + sqrt_5) / 2;  q = 1/p;  return int( (p**n + q**n) / sqrt_5 + 0.5 ) for i in range(1,31):  print analytic_fibonacci(i),"
"import java.awt.*;import javax.swing.*; public class UlamSpiral extends JPanel {     Font primeFont = new Font(""Arial"", Font.BOLD, 20);    Font compositeFont = new Font(""Arial"", Font.PLAIN, 16);     public UlamSpiral() {        setPreferredSize(new Dimension(640, 640));        setBackground(Color.white);    }     private boolean isPrime(int n) {        if (n <= 2 || n % 2 == 0)            return n == 2;        for (int i = 3; i * i <= n; i += 2)            if (n % i == 0)                return false;        return true;    }     @Override    public void paintComponent(Graphics gg) {        super.paintComponent(gg);        Graphics2D g = (Graphics2D) gg;        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,                RenderingHints.VALUE_ANTIALIAS_ON);         g.setStroke(new BasicStroke(2));         double angle = 0.0;        int x = 280, y = 330, dx = 1, dy = 0;         g.setColor(getForeground());        g.drawLine(x, y - 5, x + 50, y - 5);         for (int i = 1, step = 1, turn = 1; i < 100; i++) {             g.setColor(getBackground());            g.fillRect(x - 5, y - 20, 30, 30);            g.setColor(getForeground());            g.setFont(isPrime(i) ? primeFont : compositeFont);            g.drawString(String.valueOf(i), x + (i < 10 ? 4 : 0), y);             x += dx * 50;            y += dy * 50;             if (i == turn) {                angle += 90.0;                 if ((dx == 0 && dy == -1) || (dx == 0 && dy == 1))                    step++;                 turn += step;                 dx = (int) Math.cos(Math.toRadians(angle));                dy = (int) Math.sin(Math.toRadians(-angle));                 g.translate(9, -5);                g.drawLine(x, y, x + dx * step * 50, y + dy * step * 50);                g.translate(-9, 5);            }        }    }     public static void main(String[] args) {        SwingUtilities.invokeLater(() -> {            JFrame f = new JFrame();            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);            f.setTitle(""Ulam Spiral"");            f.setResizable(false);            f.add(new UlamSpiral(), BorderLayout.CENTER);            f.pack();            f.setLocationRelativeTo(null);            f.setVisible(true);        });    }}","var (a, b) = read(String).words.map{.to_i}...say a+b", public static IEnumerable<long> Fibs(uint x) {    IList<ulong> fibs = new List<ulong>();     ulong prev = -1;    ulong next = 1;    for (int i = 0; i < x; i++)    {     long sum = prev + next;        prev = next;        next = sum;        fibs.Add(sum);     }    return fibs;} ,(define (fib-rec n)  (if (< n 2)      n      (+ (fib-rec (- n 1))         (fib-rec (- n 2))))),"(function () {    'use strict';     function fib(n) {        return Array.apply(null, Array(n + 1))            .map(function (_, i, lst) {                return lst[i] = (                    i ? i < 2 ? 1 :                    lst[i - 2] + lst[i - 1] :                    0                );            })[n];    }     return fib(32); })();","<?php$lower = range('a', 'z');var_dump($lower);?>",let fib n =  let rec fib_aux n a b =    match n with    | 0 -> a    | _ -> fib_aux (n-1) b (a+b)  in  fib_aux n 0 1 (* support for negatives *)let fib n =       if n < 0 && n mod 2 = 0 then -fib (abs n)        else fib (abs n) ,"/* basic test */ struct IntNode {  struct MNode node;  int data;}; int main(){    int i;    LIST lista;    struct IntNode *m;    NODE n;     lista = newList();    if ( lista != NULL )    {      for(i=0; i < 5; i++)      {          m = malloc(sizeof(struct IntNode));          if ( m != NULL )          {             m->data = rand()%64;             addTail(lista, (NODE)m);          }      }      while( !isEmpty(lista) )      {            m = (struct IntNode *)remTail(lista);            printf(""%d\n"", m->data);            free(m);      }      free(lista);    }}","package ulam object Ulam {    fun generate(n: Int, i: Int = 1, c: Char = '*') {        require(n > 1)        val s = Array(n) { Array(n, { """" }) }        var dir = Direction.RIGHT        var y = n / 2        var x = if (n % 2 == 0) y - 1 else y // shift left for even n's        for (j in i..n * n - 1 + i) {            s[y][x] = if (isPrime(j)) if (c.isDigit()) ""%4d"".format(j) else ""  $c "" else "" ---""             when (dir) {                Direction.RIGHT -> if (x <= n - 1 && s[y - 1][x].none() && j > i) dir = Direction.UP                Direction.UP -> if (s[y][x - 1].none()) dir = Direction.LEFT                Direction.LEFT -> if (x == 0 || s[y + 1][x].none()) dir = Direction.DOWN                Direction.DOWN -> if (s[y][x + 1].none()) dir = Direction.RIGHT            }             when (dir) {                Direction.RIGHT -> x++                Direction.UP -> y--                Direction.LEFT -> x--                Direction.DOWN -> y++            }        }        for (row in s) println(""["" + row.joinToString("""") + ']')        println()    }     private enum class Direction { RIGHT, UP, LEFT, DOWN }     private fun isPrime(a: Int): Boolean {        when {            a == 2 -> return true            a <= 1 || a % 2 == 0 -> return false            else -> {                val max = Math.sqrt(a.toDouble()).toInt()                for (n in 3..max step 2)                    if (a % n == 0) return false                return true            }        }    }} fun main(args: Array<String>) {    Ulam.generate(9, c = '0')    Ulam.generate(9)}","(ns double-list) (defprotocol PDoubleList  (get-head [this])  (add-head [this x])  (get-tail [this])  (add-tail [this x])  (remove-node [this node])  (add-before [this node x])  (add-after [this node x])  (get-nth [this n])) (defrecord Node [prev next data]) (defn make-node  ""Create an internal or finalized node""  ([prev next data] (Node. prev next data))  ([m key] (when-let [node (get m key)]            (assoc node :m m :key key)))) (defn get-next [node] (make-node (:m node) (:next node)))(defn get-prev [node] (make-node (:m node) (:prev node))) (defn- seq* [m start next]  (seq   (for [x (iterate #(get m (next %)) (get m start))         :while x]     (:data x)))) (defmacro when->  ([x pred form] `(let [x# ~x] (if ~pred (-> x# ~form) x#)))  ([x pred form & more] `(when-> (when-> ~x ~pred ~form) [email protected]/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */))) (declare get-nth-key) (deftype DoubleList [m head tail]  Object    (equals [this x]      (and (instance? DoubleList x)           (= m (.m ^DoubleList x))))    (hashCode [this] (hash (or this ())))  clojure.lang.Sequential  clojure.lang.Counted    (count [_] (count m))  clojure.lang.Seqable    (seq [_] (seq* m head :next))  clojure.lang.Reversible    (rseq [_] (seq* m tail :prev))  clojure.lang.IPersistentCollection    (empty [_] (DoubleList. (empty m) nil nil))    (equiv [this x]      (and (sequential? x)           (= (seq x) (seq this))))    (cons [this x] (.add-tail this x))  PDoubleList    (get-head [_] (make-node m head))    (add-head [this x]      (let [new-key (Object.)            m (when-> (assoc m new-key (make-node nil head x))                head (assoc-in [head :prev] new-key))            tail (if tail tail new-key)]        (DoubleList. m new-key tail)))    (get-tail [_] (make-node m tail))    (add-tail [this x]      (if-let [tail (.get-tail this)]        (.add-after this tail x)        (.add-head this x)))    (remove-node [this node]      (if (get m (:key node))        (let [{:keys [prev next key]} node              head (if prev head next)              tail (if next tail prev)              m (when-> (dissoc m key)                  prev (assoc-in [prev :next] next)                  next (assoc-in [next :prev] prev))]          (DoubleList. m head tail))        this))    (add-after [this node x]      (if (get m (:key node))        (let [{:keys [prev next key]} node              new-key (Object.)              m (when-> (-> (assoc m new-key  (make-node key next x))                            (assoc-in , [key :next] new-key))                  next (assoc-in [next :prev] new-key))              tail (if next tail new-key)]          (DoubleList. m head tail))        this))    (add-before [this node x]      (if (:prev node)        (.add-after this (get-prev node) x)        (.add-head this x)))    (get-nth [this n] (make-node m (get-nth-key this n)))) (defn get-nth-key [^DoubleList this n]  (if (< -1 n (.count this))    (let [[start next n] (if (< n (/ (.count this) 2))                           [(.head this) :next n]                           [(.tail this) :prev (- (.count this) n 1)])]      (nth (iterate #(get-in (.m this) [% next]) start) n))    (throw (IndexOutOfBoundsException.)))) (defn double-list  ([] (DoubleList. nil nil nil))  ([coll] (into (double-list) coll))) (defmethod print-method DoubleList [dl w]  (print-method (interpose '<-> (seq dl)) w)) (defmethod print-method Node [n w]  (print-method (symbol ""#:double_list.Node"") w)  (print-method (into {} (dissoc n :m)) w))",(defun fast-fib-r (n a b)   (if (or (zp n) (zp (1- n)))       b       (fast-fib-r (1- n) b (+ a b)))) (defun fast-fib (n)   (fast-fib-r n 1 1)) (defun first-fibs-r (n i)   (declare (xargs :measure (nfix (- n i))))   (if (zp (- n i))       nil       (cons (fast-fib i)             (first-fibs-r n (1+ i))))) (defun first-fibs (n)   (first-fibs-r n 0)),"# Binary ladder, GMP if available, Pure Perl otherwiseuse ntheory qw/lucasu/;say lucasu(1, -1, 10000); # Uses GMP internal method, so similar performance as aboveuse Math::GMP;say Math::GMP::fibonacci(10000); # All Perluse Math::NumSeq::Fibonacci;my $seq = Math::NumSeq::Fibonacci->new;say $seq->ith(10000); # All Perluse Math::Big qw/fibonacci/;say 0+fibonacci(10000);  # Force scalar context # Perl, gives floating point *approximation*use Math::Fibonacci qw/term/;say term(10000);","[floor(0.01+(1/p**n+p**n)/sqrt 5)|let p=(1+sqrt 5)/2, n<-[0..42]]","def fibIter(n):    if n < 2:        return n    fibPrev = 1    fib = 1    for num in xrange(2, n):        fibPrev, fib = fib, fib + fibPrev    return fib"
public static long itFibN(int n){ if (n < 2)  return n; long ans = 0; long n1 = 0; long n2 = 1; for(n--; n > 0; n--) {  ans = n1 + n2;  n1 = n2;  n2 = ans; } return ans;},"EXPECTED = (1..9).map{|d| Math.log10(1+1.0/d)} def fib(n)  a,b = 0,1  n.times.map{ret, a, b = a, b, a+b; ret}end # powers of 3 as a test sequencedef power_of_threes(n)  n.times.map{|k| 3**k}end def heads(s)  s.map{|a| a.to_s[0].to_i}end def show_dist(title, s)  s = heads(s)  c = Array.new(10, 0)  s.each{|x| c[x] += 1}  size = s.size.to_f  res = (1..9).map{|d| c[d]/size}  puts ""\n    %s Benfords deviation"" % title  res.zip(EXPECTED).each.with_index(1) do |(r, e), i|    puts ""%2d: %5.1f%%  %5.1f%%  %5.1f%%"" % [i, r*100, e*100, (r - e).abs*100]  endend def random(n)  n.times.map{rand(1..n)}end show_dist(""fibbed"", fib(1000))show_dist(""threes"", power_of_threes(1000)) # just to show that not all kind-of-random sets behave like thatshow_dist(""random"", random(10000))", public static IEnumerable<ulong> Fibs(uint x) {    ulong prev = -1;    ulong next = 1;    for (uint i = 0; i < x; i++) {        ulong sum = prev + next;        prev = next;        next = sum;        yield return sum;    }} ,(define (fib n)  (let loop ((a 0) (b 1) (n n))    (if (= n 0) a        (loop b (+ a b) (- n 1))))) ,"function Y(dn) {    return (function(fn) {        return fn(fn);    }(function(fn) {        return dn(function() {            return fn(fn).apply(null, arguments);        });    }));}var fib = Y(function(fn) {    return function(n) {        if (n === 0 || n === 1) {            return n;        }        return fn(n - 1) + fn(n - 2);    };});","<?phpforeach (array('møøse', '𝔘𝔫𝔦𝔠𝔬𝔡𝔢', 'J̲o̲s̲é̲') as $s1) {    printf('String ""%s"" measured with strlen: %d mb_strlen: %s grapheme_strlen %s%s',                   $s1, strlen($s1),mb_strlen($s1), grapheme_strlen($s1), PHP_EOL);} ",open Num let fib =  let rec fib_aux f0 f1 = function    | 0 -> f0    | 1 -> f1    | n -> fib_aux f1 (f1 +/ f0) (n - 1)  in  fib_aux (num_of_int 0) (num_of_int 1) (* support for negatives *)let fib n =       if n < 0 && n mod 2 = 0 then minus_num (fib (abs n))        else fib (abs n);;(* It can be called from the command line with an argument *)(* Result is send to standart output *)let n = int_of_string Sys.argv.(1) in print_endline (string_of_num (fib n)) ," using System.Collections.Generic;namespace Doubly_Linked_List{    class Program    {        static void Main(string[] args)        {            LinkedList<string> list = new LinkedList<string>();            list.AddFirst("".AddFirst() adds at the head."");            list.AddLast("".AddLast() adds at the tail."");            LinkedListNode<string> head = list.Find("".AddFirst() adds at the head."");            list.AddAfter(head, "".AddAfter() adds after a specified node."");            LinkedListNode<string> tail = list.Find("".AddLast() adds at the tail."");            list.AddBefore(tail, ""Betcha can't guess what .AddBefore() does."");             System.Console.WriteLine(""Forward:"");            foreach (string nodeValue in list) { System.Console.WriteLine(nodeValue); }             System.Console.WriteLine(""\nBackward:"");            LinkedListNode<string> current = tail;            while (current != null)            {                System.Console.WriteLine(current.Value);                current = current.Previous;            }         }    }} /* Output:	Forward:	.AddFirst() adds at the head.	.AddAfter() adds after a specified node.	Betcha can't guess what .AddBefore() does.	.AddLast() adds at the tail. 	Backward:	.AddLast() adds at the tail.	Betcha can't guess what .AddBefore() does.	.AddAfter() adds after a specified node.	.AddFirst() adds at the head.*/ ","object Ulam extends App {    generate(9)()    generate(9)('*')     private object Direction extends Enumeration { val RIGHT, UP, LEFT, DOWN = Value }     private def generate(n: Int, i: Int = 1)(c: Char = 0) {        assert(n > 1, ""n > 1"")        val s = new Array[Array[String]](n).transform {_ => new Array[String](n) }         import Direction._        var dir = RIGHT        var y = n / 2        var x = if (n % 2 == 0) y - 1 else y // shift left for even n's        for (j <- i to n * n - 1 + i) {            s(y)(x) = if (isPrime(j)) if (c == 0) ""%4d"".format(j) else s""  $c "" else "" ---""             dir match {                case RIGHT => if (x <= n - 1 && s(y - 1)(x) == null && j > i) dir = UP                case UP => if (s(y)(x - 1) == null) dir = LEFT                case LEFT => if (x == 0 || s(y + 1)(x) == null) dir = DOWN                case DOWN => if (s(y)(x + 1) == null) dir = RIGHT            }             dir match {                case RIGHT => x += 1                case UP => y -= 1                case LEFT => x -= 1                case DOWN => y += 1            }        }        println(""["" + s.map(_.mkString("""")).reduceLeft(_ + ""]\n["" + _) + ""]\n"")    }     private def isPrime(a: Int): Boolean = {        if (a == 2) return true        if (a <= 1 || a % 2 == 0) return false        val max = Math.sqrt(a.toDouble).toInt        for (n <- 3 to max by 2)            if (a % n == 0) return false        true    }}","(use 'double-list);=> nil(def dl (double-list (range 10)));=> #'user/dldl;=> (0 <-> 1 <-> 2 <-> 3 <-> 4 <-> 5 <-> 6 <-> 7 <-> 8 <-> 9)(remove-node dl (get-tail dl));=> (0 <-> 1 <-> 2 <-> 3 <-> 4 <-> 5 <-> 6 <-> 7 <-> 8)dl;=> (0 <-> 1 <-> 2 <-> 3 <-> 4 <-> 5 <-> 6 <-> 7 <-> 8 <-> 9)((juxt seq rseq) dl);=> [(0 1 2 3 4 5 6 7 8 9) (9 8 7 6 5 4 3 2 1 0)](remove-node dl (get-nth dl 5));=> (0 <-> 1 <-> 2 <-> 3 <-> 4 <-> 6 <-> 7 <-> 8 <-> 9)(add-after *1 (get-nth *1 4) 10);=> (0 <-> 1 <-> 2 <-> 3 <-> 4 <-> 10 <-> 6 <-> 7 <-> 8 <-> 9)(get-head *1);=> #:double_list.Node{:prev nil, :next #<Object ...>, :data 0, :key <Object ...>}(get-next *1);=> #:double_list.Node{:prev #<Object ...>, :next #<Object ...>, :data 1, :key #<Object ...>}(get-prev *1);=> #:double_list.Node{:prev #<Object ...>, :next #<Object ...>, :data 1, :key #<Object ...>}",(defun fibonacci-iterative (n &aux (f0 0) (f1 1))  (case n    (0 f0)    (1 f1)    (t (loop for n from 2 to n             for a = f0 then b and b = f1 then result             for result = (+ a b)             finally (return result))))),"#!/usr/bin/env perl use strict;use warnings;use feature qw/say/;use List::Util qw(first); my %Likes = (  M => {    abe  => [qw/ abi eve cath ivy jan dee fay bea hope gay /],    bob  => [qw/ cath hope abi dee eve fay bea jan ivy gay /],    col  => [qw/ hope eve abi dee bea fay ivy gay cath jan /],    dan  => [qw/ ivy fay dee gay hope eve jan bea cath abi /],    ed   => [qw/ jan dee bea cath fay eve abi ivy hope gay /],    fred => [qw/ bea abi dee gay eve ivy cath jan hope fay /],    gav  => [qw/ gay eve ivy bea cath abi dee hope jan fay /],    hal  => [qw/ abi eve hope fay ivy cath jan bea gay dee /],    ian  => [qw/ hope cath dee gay bea abi fay ivy jan eve /],    jon  => [qw/ abi fay jan gay eve bea dee cath ivy hope /],  },   W => {    abi  => [qw/ bob fred jon gav ian abe dan ed col hal /],    bea  => [qw/ bob abe col fred gav dan ian ed jon hal /],    cath => [qw/ fred bob ed gav hal col ian abe dan jon /],    dee  => [qw/ fred jon col abe ian hal gav dan bob ed /],    eve  => [qw/ jon hal fred dan abe gav col ed ian bob /],    fay  => [qw/ bob abe ed ian jon dan fred gav col hal /],    gay  => [qw/ jon gav hal fred bob abe col ed dan ian /],    hope => [qw/ gav jon bob abe ian dan hal ed col fred /],    ivy  => [qw/ ian col hal gav fred bob abe ed jon dan /],    jan  => [qw/ ed hal gav abe bob jon col ian fred dan /],  },); my %Engaged;my %Proposed; match_them();check_stability();perturb();check_stability(); sub match_them {    say 'Matchmaking:';    while(my $man = unmatched_man()) {        my $woman = preferred_choice($man);        $Proposed{$man}{$woman} = 1;        if(! $Engaged{W}{$woman}) {            engage($man, $woman);            say ""\t$woman and $man"";        }        else {            if(woman_prefers($woman, $man)) {                my $engaged_man = $Engaged{W}{$woman};                engage($man, $woman);                undef $Engaged{M}{$engaged_man};                say ""\t$woman dumped $engaged_man for $man"";            }        }    }} sub check_stability {    say 'Stablility:';    my $stable = 1;    foreach my $m (men()) {        foreach my $w (women()) {            if(man_prefers($m, $w) && woman_prefers($w, $m)) {                say ""\t$w prefers $m to $Engaged{W}{$w} and $m prefers $w to $Engaged{M}{$m}"";                $stable = 0;            }        }    }    if($stable) {        say ""\t(all marriages stable)"";    }} sub unmatched_man {    return first { ! $Engaged{M}{$_} } men();} sub preferred_choice {    my $man = shift;    return first { ! $Proposed{$man}{$_} } @{ $Likes{M}{$man} };} sub engage {    my ($man, $woman) = @_;    $Engaged{W}{$woman} = $man;    $Engaged{M}{$man} = $woman;} sub prefers {    my $sex = shift;    return sub {        my ($person, $prospect) = @_;         my $choices = join ' ', @{ $Likes{$sex}{$person} };        return index($choices, $prospect) < index($choices, $Engaged{$sex}{$person});    }} BEGIN {    *woman_prefers = prefers('W');    *man_prefers   = prefers('M');} sub perturb {    say 'Perturb:';    say ""\tengage abi with fred and bea with jon"";    engage('fred' => 'abi');    engage('jon'  => 'bea');} sub men   { keys %{ $Likes{M} } }sub women { keys %{ $Likes{W} } }",fib x = if x < 1 then 0 else if x < 2 then 1 else fib(x - 1) + fib(x - 2),def fibRec(n):    if n < 2:        return n    else:        return fibRec(n-1) + fibRec(n-2)
" /** * O(log(n)) */public static long fib(long n) {    if (n <= 0)	return 0;     long i = (int) (n - 1);    long a = 1, b = 0, c = 0, d = 1, tmp1,tmp2;     while (i > 0) {	if (i % 2 != 0) {            tmp1 = d * b + c * a;	    tmp2 = d * (b + a) + c * b;	    a = tmp1;	    b = tmp2;	}         tmp1 = (long) (Math.pow(c, 2) + Math.pow(d, 2));        tmp2 = d * (2 * c + d);         c = tmp1;        d = tmp2;         i = i / 2;    }    return a + b;} ","var fibonacci = [0, 1] ;{    fibonacci.append(fibonacci[-1] + $fibonacci[-2]);} * (1000 - fibonacci.len); var (actuals, expected) = ([], []); { |i|    var num = 0;    fibonacci.each { |j| j.digit(-1) == i && (num++)};    actuals.append(num / 1000);    expected.append(1 + (1/i) -> log10);} * 9; ""%17s%17s\n"".printf(""Observed"",""Expected"");{ |i|    ""%d : %11s %%%15s %%\n"".printf(            i, ""%.2f"".sprintf(100 *  actuals[i - 1]),               ""%.2f"".sprintf(100 * expected[i - 1]),    );} * 9;"," private static double Phi = ((1d + Math.Sqrt(5d))/2d);private static double D = 1d/Math.Sqrt(5d); ulong Fib(uint n) {    if(n > 92) throw new ArgumentOutOfRangeException(""n"", n, ""Needs to be smaller than 93."");     return (ulong)((Phi^n) - (1d - Phi)^n))*D);} "," (define (fib)  (define (nxt lv nv) (cons nv (lambda () (nxt nv (+ lv nv)))))  (cons 0 (lambda () (nxt 0 1)))) ;;; test...(define (show-stream-take n strm)  (define (shw-nxt n strm) (begin (display (car strm))                                  (if (> n 1) (begin (display "" "") (shw-nxt (- n 1) ((cdr strm)))) (display "")""))))  (begin (display ""("") (shw-nxt n strm)))(show-stream-take 30 (fib))",function* fibonacciGenerator() {    var prev = 0;    var curr = 1;    while (true) {        yield curr;        curr = curr + prev;        prev = curr - prev;    }}var fib = fibonacciGenerator();,function pascalsTriangle($num){	$c = 1;	$triangle = Array();	for($i=0;$i<=$num;$i++){		$triangle[$i] = Array();		if(!isset($triangle[$i-1])){			$triangle[$i][] = $c;		}else{			for($j=0;$j<count($triangle[$i-1])+1;$j++){				$triangle[$i][] = (isset($triangle[$i-1][$j-1]) && isset($triangle[$i-1][$j])) ? $triangle[$i-1][$j-1] + $triangle[$i-1][$j] : $c;			}		}	}	return $triangle;} $tria = pascalsTriangle(8);foreach($tria as $val){	foreach($val as $value){		echo $value . ' ';	}	echo '<br>';},"open Num let mul (a,b,c) (d,e,f) = let bxe = b*/e in  (a*/d +/ bxe, a*/e +/ b*/f, bxe +/ c*/f) let id = (Int 1, Int 0, Int 1)let rec pow a n =  if n=0 then id else    let b = pow a (n/2) in    if (n mod 2) = 0 then mul b b else mul a (mul b b) let fib n =  let (_,y,_) = (pow (Int 1, Int 1, Int 0) n) in  string_of_num y;;Printf.printf ""fib %d = %s\n"" 300 (fib 300)","#include <stdio.h>#include <stdlib.h>#include <math.h> float *benford_distribution(void){    static float prob[9];    for (int i = 1; i < 10; i++)        prob[i - 1] = log10f(1 + 1.0 / i);     return prob;} float *get_actual_distribution(char *fn){    FILE *input = fopen(fn, ""r"");    if (!input)    {        perror(""Can't open file"");        exit(EXIT_FAILURE);    }     int tally[9] = { 0 };    char c;    int total = 0;    while ((c = getc(input)) != EOF)    {        /* get the first nonzero digit on the current line */        while (c < '1' || c > '9')            c = getc(input);         tally[c - '1']++;        total++;         /* discard rest of line */        while ((c = getc(input)) != '\n' && c != EOF)            ;    }    fclose(input);     static float freq[9];    for (int i = 0; i < 9; i++)        freq[i] = tally[i] / (float) total;     return freq;} int main(int argc, char **argv){    if (argc != 2)    {        printf(""Usage: benford <file>\n"");        return EXIT_FAILURE;    }     float *actual = get_actual_distribution(argv[1]);    float *expected = benford_distribution();       puts(""digit\tactual\texpected"");    for (int i = 0; i < 9; i++)        printf(""%d\t%.3f\t%.3f\n"", i + 1, actual[i], expected[i]);     return EXIT_SUCCESS;}","package fibonacci enum class Fibonacci {    ITERATIVE {        override fun invoke(n: Long) = if (n < 2 )            n        else {            var n1: Long = 0            var n2: Long = 1            var i = n            do {                val sum = n1 + n2                n1 = n2                n2 = sum            } while (i-- > 1)            n1        }    },    RECURSIVE {        override fun invoke(n: Long): Long = if (n < 2) n else this(n - 1) + this(n - 2)    };     abstract operator fun invoke(n: Long): Long} fun main(a: Array<String>) {    val r = 0..30L    Fibonacci.values().forEach {        print(""${it.name}: "")        r.forEach { i -> print("" "" + it(i)) }        println()    }}",(defn fibs []  (map first (iterate (fn [[a b]] [b (+ a b)]) [0 1]))),(defun fibonacci (n)  (let ((a 0) (b 1) (c n))    (loop for i from 2 to n do	 (setq c (+ a b)	       a b	       b c))    c)),"sub f{        my $x = shift;         return ($x * $x * $x - 3*$x*$x + 2*$x);} my $step = 0.001; # Smaller step values produce more accurate and precise resultsmy $start = -1;my $stop = 3;my $value = &f($start);my $sign = $value > 0; # Check for root at start print ""Root found at $start\n"" if ( 0 == $value ); for(    my $x = $start + $step;        $x <= $stop;        $x += $step ){        $value = &f($x);         if ( 0 == $value )        {                # We hit a root                print ""Root found at $x\n"";        }        elsif ( ( $value > 0 ) != $sign )        {                # We passed a root                print ""Root found near $x\n"";        }         # Update our sign        $sign = ( $value > 0 );}",fib x = if x < 1 then 0                  else if x==1 then 1                  else fibs!!(x - 1) + fibs!!(x - 2)  where   fibs = map fib [0..],"def fibMemo():    pad = {0:0, 1:1}    def func(n):        if n not in pad:            pad[n] = func(n-1) + func(n-2)        return pad[n]    return func fm = fibMemo()for i in range(1,31):    print fm(i),"
public static long recFibN(final int n){ return (n < 2) ? n : recFibN(n - 1) + recFibN(n - 2);},"require 'prime' def cell(n, x, y, start=1)  y, x = y - n/2, x - (n - 1)/2  l = 2 * [x.abs, y.abs].max  d = y >= x ? l*3 + x + y : l - x - y  (l - 1)**2 + d + start - 1end def show_spiral(n, symbol=nil, start=1)  puts ""\nN : #{n}""  format = ""%#{(start + n*n - 1).to_s.size}s ""  n.times do |y|    n.times do |x|      i = cell(n,x,y,start)      if symbol        print i.prime? ? symbol[0] : symbol[1]      else        print format % (i.prime? ? i : '')      end    end    puts  endend show_spiral(9)show_spiral(25)show_spiral(25, ""# "")"," public static ulong Fib(uint n) {    var M = new Matrix(1,0,0,1);    var N = new Matrix(1,1,1,0);    for (uint i = 1; i < n; i++) M *= N;    return (ulong)M[0][0];} ",;;; Fibonacci numbers using Edsger Dijkstra's algorithm;;; http://www.cs.utexas.edu/users/EWD/ewd06xx/EWD654.PDF (define (fib n)  (define (fib-aux a b p q count)    (cond ((= count 0) b)          ((even? count)           (fib-aux a                    b                    (+ (* p p) (* q q))                    (+ (* q q) (* 2 p q))                    (/ count 2)))          (else           (fib-aux (+ (* b q) (* a q) (* a p))                    (+ (* b p) (* a q))                    p                    q                    (- count 1)))))  (fib-aux 1 0 0 1 n)),"function Person(name) {     var candidateIndex = 0;     this.name = name;    this.fiance = null;    this.candidates = [];     this.rank = function(p) {        for (i = 0; i < this.candidates.length; i++)            if (this.candidates[i] === p) return i;        return this.candidates.length + 1;    }     this.prefers = function(p) {        return this.rank(p) < this.rank(this.fiance);    }     this.nextCandidate = function() {        if (candidateIndex >= this.candidates.length) return null;        return this.candidates[candidateIndex++];    }     this.engageTo = function(p) {        if (p.fiance) p.fiance.fiance = null;        p.fiance = this;        if (this.fiance) this.fiance.fiance = null;        this.fiance = p;    }     this.swapWith = function(p) {        console.log(""%s & %s swap partners"", this.name, p.name);        var thisFiance = this.fiance;        var pFiance = p.fiance;        this.engageTo(pFiance);        p.engageTo(thisFiance);    }} function isStable(guys, gals) {    for (var i = 0; i < guys.length; i++)        for (var j = 0; j < gals.length; j++)            if (guys[i].prefers(gals[j]) && gals[j].prefers(guys[i]))                return false;    return true;} function engageEveryone(guys) {    var done;    do {        done = true;        for (var i = 0; i < guys.length; i++) {            var guy = guys[i];            if (!guy.fiance) {                done = false;                var gal = guy.nextCandidate();                if (!gal.fiance || gal.prefers(guy))                    guy.engageTo(gal);            }        }    } while (!done);} function doMarriage() {     var abe  = new Person(""Abe"");    var bob  = new Person(""Bob"");    var col  = new Person(""Col"");    var dan  = new Person(""Dan"");    var ed   = new Person(""Ed"");    var fred = new Person(""Fred"");    var gav  = new Person(""Gav"");    var hal  = new Person(""Hal"");    var ian  = new Person(""Ian"");    var jon  = new Person(""Jon"");    var abi  = new Person(""Abi"");    var bea  = new Person(""Bea"");    var cath = new Person(""Cath"");    var dee  = new Person(""Dee"");    var eve  = new Person(""Eve"");    var fay  = new Person(""Fay"");    var gay  = new Person(""Gay"");    var hope = new Person(""Hope"");    var ivy  = new Person(""Ivy"");    var jan  = new Person(""Jan"");     abe.candidates  = [abi, eve, cath, ivy, jan, dee, fay, bea, hope, gay];    bob.candidates  = [cath, hope, abi, dee, eve, fay, bea, jan, ivy, gay];    col.candidates  = [hope, eve, abi, dee, bea, fay, ivy, gay, cath, jan];    dan.candidates  = [ivy, fay, dee, gay, hope, eve, jan, bea, cath, abi];    ed.candidates   = [jan, dee, bea, cath, fay, eve, abi, ivy, hope, gay];    fred.candidates = [bea, abi, dee, gay, eve, ivy, cath, jan, hope, fay];    gav.candidates  = [gay, eve, ivy, bea, cath, abi, dee, hope, jan, fay];    hal.candidates  = [abi, eve, hope, fay, ivy, cath, jan, bea, gay, dee];    ian.candidates  = [hope, cath, dee, gay, bea, abi, fay, ivy, jan, eve];    jon.candidates  = [abi, fay, jan, gay, eve, bea, dee, cath, ivy, hope];    abi.candidates  = [bob, fred, jon, gav, ian, abe, dan, ed, col, hal];    bea.candidates  = [bob, abe, col, fred, gav, dan, ian, ed, jon, hal];    cath.candidates = [fred, bob, ed, gav, hal, col, ian, abe, dan, jon];    dee.candidates  = [fred, jon, col, abe, ian, hal, gav, dan, bob, ed];    eve.candidates  = [jon, hal, fred, dan, abe, gav, col, ed, ian, bob];    fay.candidates  = [bob, abe, ed, ian, jon, dan, fred, gav, col, hal];    gay.candidates  = [jon, gav, hal, fred, bob, abe, col, ed, dan, ian];    hope.candidates = [gav, jon, bob, abe, ian, dan, hal, ed, col, fred];    ivy.candidates  = [ian, col, hal, gav, fred, bob, abe, ed, jon, dan];    jan.candidates  = [ed, hal, gav, abe, bob, jon, col, ian, fred, dan];     var guys = [abe, bob, col, dan, ed, fred, gav, hal, ian, jon];    var gals = [abi, bea, cath, dee, eve, fay, gay, hope, ivy, jan];     engageEveryone(guys);     for (var i = 0; i < guys.length; i++) {        console.log(""%s is engaged to %s"", guys[i].name, guys[i].fiance.name);    }    console.log(""Stable = %s"", isStable(guys, gals) ? ""Yes"" : ""No"");    jon.swapWith(fred);    console.log(""Stable = %s"", isStable(guys, gals) ? ""Yes"" : ""No"");} doMarriage(); ","<?php //Josephus.phpfunction Jotapata($n=41,$k=3,$m=1){$m--;	$prisoners=array_fill(0,$n,false);//make a circle of n prisoners, store false ie: dead=false	$deadpool=1;//count to next execution	$order=0;//death order and *dead* flag, ie. deadpool	while((array_sum(array_count_values($prisoners))<$n)){//while sum of count of unique values dead times < n (they start as all false)		foreach($prisoners as $thisPrisoner=>$dead){			if(!$dead){//so yeah...if not dead...				if($deadpool==$k){//if their time is up in the deadpool...					$order++;					//set the deadpool value or enumerate as survivor					$prisoners[$thisPrisoner]=((($n-$m)>($order)?$order:(($n)==$order?'Call me *Titus Flavius* Josephus':'Joe\'s friend '.(($order)-($n-$m-1)))));					$deadpool=1;//reset count to next execution				}else{$duckpool++;}			}		}	}	return $prisoners;}echo '<pre>'.print_r(Jotapata(41,3,5),true).'<pre>'; ","let men = [  ""abe"",  [""abi"";""eve"";""cath"";""ivy"";""jan"";""dee"";""fay"";""bea"";""hope"";""gay""];  ""bob"",  [""cath"";""hope"";""abi"";""dee"";""eve"";""fay"";""bea"";""jan"";""ivy"";""gay""];  ""col"",  [""hope"";""eve"";""abi"";""dee"";""bea"";""fay"";""ivy"";""gay"";""cath"";""jan""];  ""dan"",  [""ivy"";""fay"";""dee"";""gay"";""hope"";""eve"";""jan"";""bea"";""cath"";""abi""];  ""ed"",   [""jan"";""dee"";""bea"";""cath"";""fay"";""eve"";""abi"";""ivy"";""hope"";""gay""];  ""fred"", [""bea"";""abi"";""dee"";""gay"";""eve"";""ivy"";""cath"";""jan"";""hope"";""fay""];  ""gav"",  [""gay"";""eve"";""ivy"";""bea"";""cath"";""abi"";""dee"";""hope"";""jan"";""fay""];  ""hal"",  [""abi"";""eve"";""hope"";""fay"";""ivy"";""cath"";""jan"";""bea"";""gay"";""dee""];  ""ian"",  [""hope"";""cath"";""dee"";""gay"";""bea"";""abi"";""fay"";""ivy"";""jan"";""eve""];  ""jon"",  [""abi"";""fay"";""jan"";""gay"";""eve"";""bea"";""dee"";""cath"";""ivy"";""hope""];] let women = [  ""abi"",  [""bob"";""fred"";""jon"";""gav"";""ian"";""abe"";""dan"";""ed"";""col"";""hal""];  ""bea"",  [""bob"";""abe"";""col"";""fred"";""gav"";""dan"";""ian"";""ed"";""jon"";""hal""];  ""cath"", [""fred"";""bob"";""ed"";""gav"";""hal"";""col"";""ian"";""abe"";""dan"";""jon""];  ""dee"",  [""fred"";""jon"";""col"";""abe"";""ian"";""hal"";""gav"";""dan"";""bob"";""ed""];  ""eve"",  [""jon"";""hal"";""fred"";""dan"";""abe"";""gav"";""col"";""ed"";""ian"";""bob""];  ""fay"",  [""bob"";""abe"";""ed"";""ian"";""jon"";""dan"";""fred"";""gav"";""col"";""hal""];  ""gay"",  [""jon"";""gav"";""hal"";""fred"";""bob"";""abe"";""col"";""ed"";""dan"";""ian""];  ""hope"", [""gav"";""jon"";""bob"";""abe"";""ian"";""dan"";""hal"";""ed"";""col"";""fred""];  ""ivy"",  [""ian"";""col"";""hal"";""gav"";""fred"";""bob"";""abe"";""ed"";""jon"";""dan""];  ""jan"",  [""ed"";""hal"";""gav"";""abe"";""bob"";""jon"";""col"";""ian"";""fred"";""dan""];] type woman_name = stringtype man_name = string type man =  { m_name: man_name;    mutable free: bool;    women_rank: woman_name list;    has_proposed: (woman_name, unit) Hashtbl.t (* a set *)  } type woman =  { w_name: woman_name;    men_rank: man_name list;    mutable engaged: man_name option  }  let prefers w m1 m2 =  (* returns true if w has a lower (better) rank for m1 than m2 *)  let rec aux = function  | [] -> invalid_arg ""rank_cmp""  | x::_ when x = m1 -> true  | x::_ when x = m2 -> false  | _::xs -> aux xs  in  aux w.men_rank let take_while f lst =  let rec aux acc = function  | x::xs when f x -> aux (x::acc) xs  | _ -> List.rev acc  in  aux [] lst let more_ranked_than name =  take_while ((<>) name) let build_structs ~men ~women =  List.map (fun (name, rank) ->    { m_name = name;      women_rank = rank;      free = true;      has_proposed = Hashtbl.create 42 }  ) men,  List.map (fun (name, rank) ->    { w_name = name;      men_rank = rank;      engaged = None }  ) women  let _stable_matching ms ws =  let men_by_name = Hashtbl.create 42 in  List.iter (fun m -> Hashtbl.add men_by_name m.m_name m) ms;  let women_by_name = Hashtbl.create 42 in  List.iter (fun w -> Hashtbl.add women_by_name w.w_name w) ws;  try    while true do      (*TODO free men who still has some w to propose to *)      let m = List.find (fun m -> m.free) ms in      (* highest ranked woman who the man has not proposed to yet *)      let w_name =        List.find (fun w -> not (Hashtbl.mem m.has_proposed w)) m.women_rank in      Hashtbl.add m.has_proposed w_name ();      let w = Hashtbl.find women_by_name w_name in      match w.engaged with      | None -> (* w is free *)          (* (m, w) become engaged *)          w.engaged <- Some m.m_name;          m.free <- false      | Some m'_name -> (* some pair (m', w) already exists *)          if prefers w m.m_name m'_name          then begin (* w prefers m to m' *)            w.engaged <- Some m.m_name;            let m' = Hashtbl.find men_by_name m'_name in            m'.free <- true;            m.free <- false          end    done;    assert false  with Not_found -> ()  let stable_matching ~men ~women =  let ms, ws = build_structs ~men ~women in  _stable_matching ms ws;  let some = function Some v -> v | None -> """" in  List.map (fun w -> w.w_name, some w.engaged) ws  let is_stable ~men ~women eng =  let ms, ws = build_structs ~men ~women in  not (List.exists (fun (wn, mn) ->      let m = List.find (fun m -> m.m_name = mn) ms in      let prefered_women = more_ranked_than wn m.women_rank in      List.exists (fun pref_w ->        let w = List.find (fun w -> w.w_name = pref_w) ws in        let eng_m = List.assoc pref_w eng in        let prefered_men = more_ranked_than eng_m w.men_rank in        List.mem m.m_name prefered_men (* exists unstable engagement *)      ) prefered_women    ) eng)  let perturb_engagements eng =  Random.self_init();  let eng = Array.of_list eng in  let len = Array.length eng in  for n = 1 to 3 do    let i = Random.int len    and j = Random.int len in    let w1, m1 = eng.(i)    and w2, m2 = eng.(j) in    eng.(i) <- (w1, m2);    eng.(j) <- (w2, m1);  done;  Array.to_list eng  let print engs =  List.iter (fun (w,m) ->    Printf.printf "" %4s is engaged with %s\n"" w m) engs;  Printf.printf ""# Engagements %s stable\n""    (if is_stable ~men ~women engs then ""are"" else ""are not"") let () =  let engagements = stable_matching ~men ~women in  print engagements;  print_endline ""========================"";  let engagements = perturb_engagements engagements in  print engagements;;;"," #include <stdio.h>#include <stdint.h>#include <stdlib.h>#include <math.h> typedef uint32_t bitsieve; unsigned sieve_check(bitsieve *b, const unsigned v){    if ((v != 2 && !(v & 1)) || (v < 2))        return 0;    else        return !(b[v >> 6] & (1 << (v >> 1 & 31)));} bitsieve* sieve(const unsigned v){    unsigned i, j;    bitsieve *b = calloc((v >> 6) + 1, sizeof(uint32_t));     for (i = 3; i <= sqrt(v); i += 2)        if (!(b[i >> 6] & (1 << (i >> 1 & 31))))            for (j = i*i; j < v; j += (i << 1))                b[j >> 6] |= (1 << (j >> 1 & 31));     return b;} #define max(x,y) ((x) > (y) ? (x) : (y)) /* This mapping taken from python solution */int ulam_get_map(int x, int y, int n){    x -= (n - 1) / 2;    y -= n / 2;     int mx = abs(x), my = abs(y);    int l = 2 * max(mx, my);    int d = y > x ? l * 3 + x + y : l - x - y;     return pow(l - 1, 2) + d;} /* Passing a value of 0 as glyph will print numbers */void output_ulam_spiral(int n, const char glyph){    /* An even side length does not make sense, use greatest odd value < n */    n -= n % 2 == 0 ? 1 : 0;     const char *spaces = ""................."";    int mwidth = log10(n * n) + 1;     bitsieve *b = sieve(n * n + 1);    int x, y;     for (x = 0; x < n; ++x) {        for (y = 0; y < n; ++y) {            int z = ulam_get_map(y, x, n);             if (glyph == 0) {                if (sieve_check(b, z))                    printf(""%*d "", mwidth, z);                else                    printf(""%.*s "", mwidth, spaces);            }            else {                printf(""%c"", sieve_check(b, z) ? glyph : spaces[0]);            }        }        printf(""\n"");    }     free(b);} int main(int argc, char *argv[]){    const int n = argc < 2 ? 9 : atoi(argv[1]);     output_ulam_spiral(n, 0);    printf(""\n"");     output_ulam_spiral(n, '#');    printf(""\n"");     return 0;} ",def fib(i:Int):Int = i match{    case 0 => 0    case 1 => 1    case _ => fib(i-1) + fib(i-2)},(nth (fibs) 5),(loop for x = 0 then y and y = 1 then (+ x y) do (print x)),"use utf8;package ErrVar;use strict; # helper function, apply f to pairs (a, b) from listX and listYsub zip(&$$) {	my ($f, $x, $y) = @_;	my $l = $#$x;	if ($l < $#$y) { $l = $#$y }; 	my @out;	for (0 .. $l) {		local $a = $x->[$_];		local $b = $y->[$_];		push @out, $f->();	}	\@out} use overload	'""""'	=> \&_str,	'+'	=> \&_add,	'-'	=> \&_sub,	'*'	=> \&_mul,	'/'	=> \&_div,	'bool'	=> \&_bool,	'<=>'	=> \&_ncmp,	'neg'	=> \&_neg, 	'sqrt'	=> \&_sqrt,	'log'	=> \&_log,	'exp'	=> \&_exp,	'**'	=> \&_pow,; # make a variable with mean value and a list of coefficient to# variables providing independent errorssub make {	my $x = shift;	bless [$x, [@{+shift}]]} sub _str { sprintf ""%g±%.3g"", $_[0][0], sigma($_[0]) } # mean value of the var, or just the input if it's not of this classsub mean {	my $x = shift;	ref($x) && $x->isa(__PACKAGE__) ? $x->[0] : $x} # return variance index arraysub vlist {	my $x = shift;	ref($x) && $x->isa(__PACKAGE__) ? $x->[1] : [];} sub variance {	my $x = shift;	return 0 unless ref($x) and $x->isa(__PACKAGE__);	my $s;	$s += $_ * $_ for (@{$x->[1]});	$s} sub covariance {	my ($x, $y) = @_;	return 0 unless ref($x) && $x->isa(__PACKAGE__);	return 0 unless ref($y) && $y->isa(__PACKAGE__); 	my $s;	zip { $s += $a * $b } vlist($x), vlist($y);	$s} sub sigma { sqrt variance(shift) } # to determine if a var is probably zero. we use 1σ heresub _bool {	my $x = shift;	return abs(mean($x)) > sigma($x);} sub _ncmp {	my $x = shift() - shift()	or return 0;	return mean($x) > 0 ? 1 : -1;} sub _neg {	my $x = shift;	bless [ -mean($x), [map(-$_, @{vlist($x)}) ] ];} sub _add {	my ($x, $y) = @_;	my ($x0, $y0) = (mean($x), mean($y));	my ($xv, $yv) = (vlist($x), vlist($y));	bless [$x0 + $y0, zip {$a + $b} $xv, $yv];} sub _sub {	my ($x, $y, $swap) = @_;	if ($swap) { ($x, $y) = ($y, $x) }	my ($x0, $y0) = (mean($x), mean($y));	my ($xv, $yv) = (vlist($x), vlist($y));	bless [$x0 - $y0, zip {$a - $b} $xv, $yv];} sub _mul {	my ($x, $y) = @_;	my ($x0, $y0) = (mean($x), mean($y));	my ($xv, $yv) = (vlist($x), vlist($y)); 	$xv = [ map($y0 * $_, @$xv) ];	$yv = [ map($x0 * $_, @$yv) ]; 	bless [$x0 * $y0, zip {$a + $b} $xv, $yv];} sub _div {	my ($x, $y, $swap) = @_;	if ($swap) { ($x, $y) = ($y, $x) } 	my ($x0, $y0) = (mean($x), mean($y));	my ($xv, $yv) = (vlist($x), vlist($y)); 	$xv = [ map($_/$y0, @$xv) ];	$yv = [ map($x0 * $_/$y0/$y0, @$yv) ]; 	bless [$x0 / $y0, zip {$a + $b} $xv, $yv];} sub _sqrt {	my $x = shift;	my $x0 = mean($x);	my $xv = vlist($x);	$x0 = sqrt($x0);	$xv = [ map($_ / 2 / $x0, @$xv) ];	bless [$x0, $xv]} sub _pow {	my ($x, $y, $swap) = @_;	if ($swap) { ($x, $y) = ($y, $x) }	if ($x < 0) {		if (int($y) != $y || ($y & 1)) {			die ""Can't take pow of negative number $x"";		}		$x = -$x;	}	exp($y * log $x)} sub _exp {	my $x = shift;	my $x0 = exp(mean($x));	my $xv = vlist($x);	bless [ $x0, [map($x0 * $_, @$xv) ] ]} sub _log {	my $x = shift;	my $x0 = mean($x);	my $xv = vlist($x);	bless [ log($x0), [ map($_ / $x0, @$xv) ] ]} ""If this package were to be in its own file, you need some truth value to end it like this.""; package main; sub e { ErrVar::make @_ }; # x1 is of mean value 100, containing error 1.1 from source 1, etc.# all error sources are independent.my $x1 = e 100, [1.1, 0,   0,   0  ];my $x2 = e 200, [0,   2.2, 0,   0  ];my $y1 = e 50,  [0,   0,   1.2, 0  ];my $y2 = e 100, [0,   0,   0,   2.3]; my $z1 = sqrt(($x1 - $x2) ** 2 + ($y1 - $y2) ** 2);print ""distance: $z1\n\n""; # this is not for task requirementmy $a = $x1 + $x2;my $b = $y1 - 2 * $x2;print ""covariance between $a and $b: "", $a->covariance($b), ""\n"";",fib n = go n 0 1    where    go n a b | n==0 = a             | otherwise = go (n-1) b (a+b),"def fibFastRec(n):    def fib(prvprv, prv, c):        if c < 1:             return prvprv        else:             return fib(prv, prvprv + prv, c - 1)     return fib(0, 1, n)"
"public static long anFibN(final long n){ double p = (1 + Math.sqrt(5)) / 2; double q = 1 / p; return (long) ((Math.pow(p, n) + Math.pow(q, n)) / Math.sqrt(5));}","require 'prime' def spiral_generator(x=0, y=0)  Enumerator.new do |yielder|    yielder << [x, y]                           # start position    dx, dy = 0, 1                               # first direction    yielder << [x+=dx, y+=dy]                   # second position    0.step do |i|      2.times do        i.times{ yielder << [x+=dx, y+=dy] }    # going straight        dx, dy = -dy, dx                        # 90 degree turn        yielder << [x+=dx, y+=dy]      end    end  endend def ulam_spiral(n, start=1)  h = Hash.new(0)  position = spiral_generator  (start ... start+n*n).each do |i|    pos = position.next    h[pos] = 1  if i.prime?  end   chr = [[' ', '▄'], ['▀', '█']]  (xmin, xmax), (ymin, ymax) = h.keys.transpose.map(&:minmax)  (xmin..xmax).step(2).each do |x|    puts (ymin..ymax).map{|y| chr[h[[x,y]]][h[[x+1,y]]]}.join  endend [11, 122].each do |n|  puts ""\nN : #{n}""  ulam_spiral(n)end"," private static Matrix M;private static readonly Matrix N = new Matrix(1,1,1,0); public static ulong Fib(uint n) {    M = new Matrix(1,0,0,1);    MatrixPow(n-1);    return (ulong)M[0][0];} private static void MatrixPow(double n){    if (n > 1) {        MatrixPow(n/2);        M *= M;    }    if (n % 2 == 0) M *= N;} ", (lib 'hash);; input data(define M-RANKS '(( abe abi eve cath ivy jan dee fay bea hope gay)(  bob cath hope abi dee eve fay bea jan ivy gay)(  col hope eve abi dee bea fay ivy gay cath jan)(  dan ivy fay dee gay hope eve jan bea cath abi)(   ed jan dee bea cath fay eve abi ivy hope gay)( fred bea abi dee gay eve ivy cath jan hope fay)(  gav gay eve ivy bea cath abi dee hope jan fay)(  hal abi eve hope fay ivy cath jan bea gay dee)(  ian hope cath dee gay bea abi fay ivy jan eve)(  jon abi fay jan gay eve bea dee cath ivy hope))) (define W-RANKS '((  abi bob fred jon gav ian abe dan ed col hal)(  bea bob abe col fred gav dan ian ed jon hal)( cath fred bob ed gav hal col ian abe dan jon)(  dee fred jon col abe ian hal gav dan bob ed)(  eve jon hal fred dan abe gav col ed ian bob)(  fay bob abe ed ian jon dan fred gav col hal)(  gay jon gav hal fred bob abe col ed dan ian)( hope gav jon bob abe ian dan hal ed col fred)(  ivy ian col hal gav fred bob abe ed jon dan)(  jan ed hal gav abe bob jon col ian fred dan))) ;; build preferences hash(define (set-prefs ranks  prefs)    (for/list ((r ranks))        (hash-set prefs (first r) (rest r))        (first r))) (define (engage  m w)    (hash-set ENGAGED m w) (hash-set ENGAGED w m) (writeln  m w '👫 ))(define (disengage  m w) (hash-remove! ENGAGED m ) (hash-remove! ENGAGED w) (writeln '💔 m w))(define (engaged x)      (hash-ref ENGAGED x))(define (free? x)        (not (engaged x)))(define (free-man men)   (for ((man men)) #:break (free? man) => man  #f))  (define (prefers? prefs x a b) (member b  (member a (hash-ref prefs x))));; get first choice and remove it from prefs list(define (first-choice prefs m)     (define w (first (hash-ref prefs m)))    (hash-set prefs m (rest (hash-ref prefs m)))    w) ;; sets ENGAGED couples;;  https//en.wikipedia.org/wiki/Stable_marriage_problem (define (stableMatching  (prefs (make-hash)) (m) (w))(define-global 'ENGAGED (make-hash))  (define men   (set-prefs  M-RANKS prefs))  (define women (set-prefs  W-RANKS prefs))    (while (setv! m (free-man men))        (set! w (first-choice prefs m))        (if (free? w)            (engage m w)            (let [(dumped (engaged w))]            (when (prefers? prefs w m dumped)                (disengage w dumped)                (engage w m))))) (hash->list ENGAGED)) ;; input : ENGAGED couples(define (checkStable (prefs (make-hash)))  (define men   (set-prefs  M-RANKS  prefs))  (define women (set-prefs  W-RANKS  prefs))	(for* [(man men) (woman women)]	#:continue (equal? woman (engaged man))			(when (and 					(prefers? prefs man woman (engaged man))					(prefers? prefs woman man (engaged woman)))					(error 'not-stable (list man woman)))))  ," // This function notation is sorta new, but useful here// Part of the EcmaScript 6 Draft// developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scopevar poly = (x => x*x*x - 3*x*x + 2*x); function sign(x) {	return (x < 0.0) ? -1 : (x > 0.0) ? 1 : 0;} function printRoots(f, lowerBound, upperBound, step) {	var  x = lowerBound, ox = x,		 y = f(x), oy = y,		 s = sign(y), os = s; 	for (; x <= upperBound ; x += step) {	    s = sign(y = f(x));	    if (s == 0) {			console.log(x);	    }	    else if (s != os) {			var dx = x - ox;			var dy = y - oy;			var cx = x - dx * (y / dy);			console.log(""~"" + cx);	    }	    ox = x; oy = y; os = s;	}} printRoots(poly, -1.0, 4, 0.002); ","function multiply( $a, $b ){    return $a * $b;}","let bracket u v =  ((u > 0.0) && (v < 0.0)) || ((u < 0.0) && (v > 0.0));; let xtol a b = (a = b);; (* or use |a-b| < epsilon *) let rec regula_falsi a b fa fb f =  if xtol a b then (a, fa) else  let c = (fb*.a -. fa*.b) /. (fb -. fa) in  let fc = f c in  if fc = 0.0 then (c, fc) else  if bracket fa fc then    regula_falsi a c fa fc f  else    regula_falsi c b fc fb f;; let search lo hi step f =  let rec next x fx =    if x > hi then [] else      let y = x +. step in      let fy = f y in      if fx = 0.0 then        (x,fx) :: next y fy      else if bracket fx fy then        (regula_falsi x y fx fy f) :: next y fy      else        next y fy in  next lo (f lo);; let showroot (x,fx) =  Printf.printf ""f(%.17f) = %.17f [%s]\n""     x fx (if fx = 0.0 then ""exact"" else ""approx"") inlet f x = ((x -. 3.0)*.x +. 2.0)*.x  inList.iter showroot (search (-5.0) 5.0 0.1 f);;","#include <stdio.h>#include <stdlib.h> int isprime(int n){	int p;	for (p = 2; p*p <= n; p++)		if (n%p == 0) return 0;	return n > 2;} int spiral(int w, int h, int x, int y){	return y ? w + spiral(h - 1, w, y - 1, w - x - 1) : x;} int main(int c, char **v){	int i, j, w = 50, h = 50, s = 1;	if (c > 1 && (w = atoi(v[1])) <= 0) w = 50;	if (c > 2 && (h = atoi(v[2])) <= 0) h = w;	if (c > 3 && (s = atoi(v[3])) <= 0) s = 1; 	for (i = 0; i < h; i++) {		for (j = 0; j < w; j++)			putchar(isprime(w*h + s - 1 - spiral(w, h, j, i))["" #""]);		putchar('\n');	}	return 0;}","lazy val fib: Stream[Int] = 0 #:: 1 #:: fib.zip(fib.tail).map{case (a,b) => a + b}","(defn fibs []  (map first ;; throw away the ""metadata"" (see below) to view just the fib numbers       (iterate ;; create an infinite sequence of [prev, curr] pairs         (fn [[a b]] ;; to produce the next pair, call this function on the current pair           [b (+ a b)]) ;; new prev is old curr, new curr is sum of both previous numbers         [0 1]))) ;; recursive base case: prev 0, curr 1",(defun fibonacci-recursive (n)  (if (< n 2)      n     (+ (fibonacci-recursive (- n 2)) (fibonacci-recursive (- n 1))))),"#!/usr/bin/perluse warnings;use strict;use feature qw{ say }; {   my @ludic = (1);    my $max = 3;    my @candidates;     sub sieve {        my $l = shift;        for (my $i = 0; $i <= $#candidates; $i += $l) {            splice @candidates, $i, 1;        }    }     sub ludic {        my ($type, $n) = @_;        die ""Arg0 Type must be 'count' or 'max'\n""             unless grep $_ eq $type, qw( count max );        die ""Arg1 Number must be > 0\n"" if 0 >= $n;         return (@ludic[ 0 .. $n - 1 ]) if 'count' eq $type and @ludic >= $n;         return (grep $_ <= $n, @ludic) if 'max'   eq $type and $ludic[-1] >= $n;         while (1) {            if (@candidates) {                last if ('max' eq $type and $candidates[0] > $n)                     or ($n == @ludic);                 push @ludic, $candidates[0];                sieve($ludic[-1] - 1);             } else {                $max *= 2;                @candidates = 2 .. $max;                for my $l (@ludic) {                    sieve($l - 1) unless 1 == $l;                }            }        }        return (@ludic)    } } my @triplet;my %ludic;undef @ludic{ ludic(max => 250) };for my $i (keys %ludic) {    push @triplet, $i if exists $ludic{ $i + 2 } and exists $ludic { $i + 6 };} say 'First 25:       ', join ' ', ludic(count => 25);say 'Count < 1000:   ', scalar ludic(max => 1000);say '2000..2005th:   ', join ' ', (ludic(count => 2005))[1999 .. 2004];say 'triplets < 250: ', join ' ',                        map { '(' . join(' ',$_, $_ + 2, $_ + 6) . ')' }                        sort { $a <=> $b } @triplet;",fib = 0 : 1 : zipWith (+) fib (tail fib),"def fibGen(n):    a, b = 0, 1    while n>0:        yield a        a, b, n = b, a+b, n-1"
"public static long fibTailRec(final int n){ return fibInner(0, 1, n);} private static long fibInner(final long a, final long b, final int n){ return n < 1 ? a : n == 1 ?  b : fibInner(b, a + b, n - 1);}","require('Imager'); var (n=512, start=1, file='ulam.png') = ARGV»to_i»()...; func cell(n, x, y, start) {    y -= (n   >> 1);    x -= (n-1 >> 1);    var l = 2*(x.abs > y.abs ? x.abs : y.abs);    var d = (y > x  ? (l*3 + x + y) : (l - x - y));    (l-1)**2 + d + start - 1;} var black = %s'Imager::Color'.new('#000000');var white = %s'Imager::Color'.new('#FFFFFF'); var img = %s'Imager'.new(xsize => n, ysize => n, channels => 1);img.box(filled => 1, color => white); for y in ^n {    for x in ^n {        var v = cell(n, x, y, start);        v.is_prime &&            img.setpixel(x => x, y => y, color => black);    }} img.write(file => file);"," private static int[] fibs = new int[]{ -1836311903, 1134903170,   -701408733, 433494437, -267914296, 165580141, -102334155,   63245986, -39088169, 24157817, -14930352, 9227465, -5702887,   3524578, -2178309, 1346269, -832040, 514229, -317811, 196418,   -121393, 75025, -46368, 28657, -17711, 10946, -6765, 4181,   -2584, 1597, -987, 610, -377, 233, -144, 89, -55, 34, -21, 13,   -8, 5, -3, 2, -1, 1, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89,   144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711,  28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040,  1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817,  39088169, 63245986, 102334155, 165580141, 267914296, 433494437,  701408733, 1134903170, 1836311903}; public static int Fib(int n) {    if(n < -46 || n > 46) throw new ArgumentOutOfRangeException(""n"", n, ""Has to be between -46 and 47."")    return fibs[n+46];} ", ;; square num is i + j*N(define-syntax-rule (sq i j) (+ i (* j N))) ;; compute diag number for each square(define (do-diag1 i0 j0  dnum  into: dnum1 N) ;; ++i and ++j diags	(for [(i (in-range i0 N)) (j (in-range j0 N))]		;;(writeln   i j 'diag1 dnum)		(vector-set! dnum1 (sq i j) dnum))) (define (do-diag2 i0 j0  dnum into: dnum2 N) ;; --i and ++j diags	(for [(i (in-range i0 -1 -1)) (j (in-range j0 N))]		;; (writeln i j 'diag2 dnum)		(vector-set! dnum2 (sq i j) dnum))) (define (init-diags dnum1 dnum2 N)	(define dnum 0)		(for ((j N)) (do-diag1 0 j dnum dnum1 N) (++ dnum))		(for ((i (in-range 1 N)))                      (do-diag1 i 0 dnum dnum1  N) (++ dnum))	(set! dnum 0)		(for ((j N)) (do-diag2 (1- N) j dnum dnum2 N) (++ dnum))		(for ((i (1- N))) (do-diag2 i 0 dnum dnum2 N) (++ dnum)));; end boring diags part (define (q-search i  N col diag1 diag2 dnum1 dnum2    &hits (ns))(cond[(= i N)  (set-box! &hits (1+ (unbox &hits))) ] ;;  (writeln  'HIT col)	[else 		(for ((j N))		(set! ns (sq i j))		#:continue (or [col j] [diag1 [dnum1 ns]] [diag2 [dnum2 ns]])		     (vector-set! col j i) ;; move		     (vector-set! diag1 [dnum1 ns] #t) ;; flag busy diagonal			(vector-set! diag2 [dnum2 ns] #t)			(q-search (1+ i) N col diag1 diag2 dnum1 dnum2 &hits)			(vector-set! col j #f) ;; unmove			(vector-set! diag1 [dnum1 ns] #f)			(vector-set! diag2 [dnum2 ns] #f))			])) (define (q-count (N 8))	(define dnum1 (make-vector (* N N)))	(define dnum2 (make-vector (* N N )))	(init-diags dnum1 dnum2 N) 	(define diag1 (make-vector (* 2 N) #f)) ; busy diag's	(define diag2 (make-vector (* 2 N) #f))	(define col (make-vector N  #f))	(define &hits (box 0))  	(q-search 0 N col diag1 diag2 dnum1 dnum2  &hits)	(unbox &hits)) (define (task up-to-n)	(for ((i up-to-n)) (writeln i ' ♕ (q-count i) 'solutions))) ," function queenPuzzle(rows, columns) {    if (rows <= 0) {        return [[]];    } else {        return addQueen(rows - 1, columns);    }} function addQueen(newRow, columns, prevSolution) {    var newSolutions = [];    var prev = queenPuzzle(newRow, columns);    for (var i = 0; i < prev.length; i++) {        var solution = prev[i];        for (var newColumn = 0; newColumn < columns; newColumn++) {            if (!hasConflict(newRow, newColumn, solution))                newSolutions.push(solution.concat([newColumn]))        }    }    return newSolutions;} function hasConflict(newRow, newColumn, solution) {    for (var i = 0; i < newRow; i++) {        if (solution[i]     == newColumn          ||            solution[i] + i == newColumn + newRow ||             solution[i] - i == newColumn - newRow) {                return true;        }    }    return false;} console.log(queenPuzzle(8,8)); ","multiply(A, B) = A*B. ","(* Authors: Nicolas Barnier, Pascal Brisset   Copyright 2004 CENA. All rights reserved.   This code is distributed under the terms of the GNU LGPL *) open Facileopen Easy (* Print a solution *)let print queens =  let n = Array.length queens in  if n <= 10 then (* Pretty printing *)    for i = 0 to n - 1 do      let c = Fd.int_value queens.(i) in (* queens.(i) is bound *)      for j = 0 to n - 1 do        Printf.printf ""%c "" (if j = c then '*' else '-')      done;      print_newline ()    done  else (* Short print *)    for i = 0 to n-1 do      Printf.printf ""line %d : col %a\n"" i Fd.fprint queens.(i)    done;  flush stdout;;; (* Solve the n-queens problem *)let queens n =  (* n decision variables in 0..n-1 *)  let queens = Fd.array n 0 (n-1) in   (* 2n auxiliary variables for diagonals *)  let shift op = Array.mapi (fun i qi -> Arith.e2fd (op (fd2e qi) (i2e i))) queens in  let diag1 = shift (+~) and diag2 = shift (-~) in   (* Global constraints *)  Cstr.post (Alldiff.cstr queens);  Cstr.post (Alldiff.cstr diag1);  Cstr.post (Alldiff.cstr diag2);   (* Heuristic Min Size, Min Value *)  let h a = (Var.Attr.size a, Var.Attr.min a) in  let min_min = Goals.Array.choose_index (fun a1 a2 -> h a1 < h a2) in   (* Search goal *)  let labeling = Goals.Array.forall ~select:min_min Goals.indomain in   (* Solve *)  let bt = ref 0 in  if Goals.solve ~control:(fun b -> bt := b) (labeling queens) then begin    Printf.printf ""%d backtracks\n"" !bt;    print queens  end else    prerr_endline ""No solution"" let _ =  if Array.length Sys.argv <> 2  then raise (Failure ""Usage: queens <nb of queens>"");  Gc.set ({(Gc.get ()) with Gc.space_overhead = 500}); (* May help except with an underRAMed system *)  queens (int_of_string Sys.argv.(1));;"," // Fibonacci sequence, recursive versionfun fibb    loop        a = funparam[0]        break (a < 2)         a--         // Save ""a"" while calling fibb        a -> stack         // Set the parameter and call fibb        funparam[0] = a        call fibb         // Handle the return value and restore ""a""        b = funparam[0]        stack -> a         // Save ""b"" while calling fibb again        b -> stack         a--         // Set the parameter and call fibb        funparam[0] = a        call fibb         // Handle the return value and restore ""b""        c = funparam[0]        stack -> b         // Sum the results        b += c        a = b         funparam[0] = a         break    endend // vim: set syntax=c ts=4 sw=4 et: ","def fib(x:Int, prev: BigInt = 0, next: BigInt = 1):BigInt = x match {    case 0 => prev    case 1 => next    case _ => fib(x-1, next, (next + prev)) }",(def fib (lazy-cat [0 1] (map + fib (rest fib)))),(defun fibonacci-tail-recursive ( n &optional (a 0) (b 1))  (if (= n 0)       a       (fibonacci-tail-recursive (- n 1) b (+ a b)))),"my ($board_size, @occupied, @past, @solutions); sub try_column {        my ($depth, @diag) = shift;        if ($depth == $board_size) {                push @solutions, ""@past\n"";                return;        }         # @diag: marks cells diagonally attackable by any previous queens.        #        Here it's pre-allocated to double size just so we don't need        #        to worry about negative indices.        $#diag = 2 * $board_size;        for (0 .. $#past) {                $diag[ $past[$_] + $depth - $_ ] = 1;                $diag[ $past[$_] - $depth + $_ ] = 1;        }         for my $row (0 .. $board_size - 1) {                next if $occupied[$row] || $diag[$row];                 # @past:     row numbers of previous queens                # @occupied: rows already used. This gets inherited by each                #            recursion so we don't need to repeatedly look them up                push @past, $row;                $occupied[$row] = 1;                 try_column($depth + 1);                 # clean up, for next recursion                $occupied[$row] = 0;                pop @past;        }} $board_size = 12;  # takes a minute or so, 14,200 solutionstry_column(0); local $"" = ""\n"";print @solutions;print ""total "", scalar(@solutions), "" solutions\n"";",fib = 0 : 1 : next fib where next (a: t@(b:_)) = (a+b) : next t," >>> [i for i in fibGen(11)] [0,1,1,2,3,5,8,13,21,34,55] "
"public class Roots {    public interface Function {	public double f(double x);    }     private static int sign(double x) {	return (x < 0.0) ? -1 : (x > 0.0) ? 1 : 0;    }     public static void printRoots(Function f, double lowerBound,				  double upperBound, double step) {	double x = lowerBound, ox = x;	double y = f.f(x), oy = y;	int s = sign(y), os = s; 	for (; x <= upperBound ; x += step) {	    s = sign(y = f.f(x));	    if (s == 0) {		System.out.println(x);	    } else if (s != os) {		double dx = x - ox;		double dy = y - oy;		double cx = x - dx * (y / dy);		System.out.println(""~"" + cx);	    }	    ox = x; oy = y; os = s;	}    }     public static void main(String[] args) {	Function poly = new Function () {	    public double f(double x) {		return x*x*x - 3*x*x + 2*x;	    }	};	printRoots(poly, -1.0, 4, 0.002);    }}","def fib(n, sequence=[1])  n.times do    current_number, last_number = sequence.last(2)    sequence << current_number + (last_number or 0)  end   sequence.lastend","using System;using System.Collections.Generic; namespace StableMarriage{    class Person    {        private int _candidateIndex;        public string Name { get; set; }        public List<Person> Prefs { get; set; }        public Person Fiance { get; set; }         public Person(string name) {            Name = name;            Prefs = null;            Fiance = null;            _candidateIndex = 0;        }        public bool Prefers(Person p) {            return Prefs.FindIndex(o => o == p) < Prefs.FindIndex(o => o == Fiance);        }        public Person NextCandidateNotYetProposedTo() {            if (_candidateIndex >= Prefs.Count) return null;            return Prefs[_candidateIndex++];        }        public void EngageTo(Person p) {            if (p.Fiance != null) p.Fiance.Fiance = null;            p.Fiance = this;            if (Fiance != null) Fiance.Fiance = null;            Fiance = p;        }    }     static class MainClass    {        static public bool IsStable(List<Person> men) {            List<Person> women = men[0].Prefs;            foreach (Person guy in men) {                foreach (Person gal in women) {                    if (guy.Prefers(gal) && gal.Prefers(guy))                        return false;                }            }            return true;        }         static void DoMarriage() {            Person abe  = new Person(""abe"");            Person bob  = new Person(""bob"");            Person col  = new Person(""col"");            Person dan  = new Person(""dan"");            Person ed   = new Person(""ed"");            Person fred = new Person(""fred"");            Person gav  = new Person(""gav"");            Person hal  = new Person(""hal"");            Person ian  = new Person(""ian"");            Person jon  = new Person(""jon"");            Person abi  = new Person(""abi"");            Person bea  = new Person(""bea"");            Person cath = new Person(""cath"");            Person dee  = new Person(""dee"");            Person eve  = new Person(""eve"");            Person fay  = new Person(""fay"");            Person gay  = new Person(""gay"");            Person hope = new Person(""hope"");            Person ivy  = new Person(""ivy"");            Person jan  = new Person(""jan"");             abe.Prefs  = new List<Person>() {abi, eve, cath, ivy, jan, dee, fay, bea, hope, gay};            bob.Prefs  = new List<Person>() {cath, hope, abi, dee, eve, fay, bea, jan, ivy, gay};            col.Prefs  = new List<Person>() {hope, eve, abi, dee, bea, fay, ivy, gay, cath, jan};            dan.Prefs  = new List<Person>() {ivy, fay, dee, gay, hope, eve, jan, bea, cath, abi};            ed.Prefs   = new List<Person>() {jan, dee, bea, cath, fay, eve, abi, ivy, hope, gay};            fred.Prefs = new List<Person>() {bea, abi, dee, gay, eve, ivy, cath, jan, hope, fay};            gav.Prefs  = new List<Person>() {gay, eve, ivy, bea, cath, abi, dee, hope, jan, fay};            hal.Prefs  = new List<Person>() {abi, eve, hope, fay, ivy, cath, jan, bea, gay, dee};            ian.Prefs  = new List<Person>() {hope, cath, dee, gay, bea, abi, fay, ivy, jan, eve};            jon.Prefs  = new List<Person>() {abi, fay, jan, gay, eve, bea, dee, cath, ivy, hope};            abi.Prefs  = new List<Person>() {bob, fred, jon, gav, ian, abe, dan, ed, col, hal};            bea.Prefs  = new List<Person>() {bob, abe, col, fred, gav, dan, ian, ed, jon, hal};            cath.Prefs = new List<Person>() {fred, bob, ed, gav, hal, col, ian, abe, dan, jon};            dee.Prefs  = new List<Person>() {fred, jon, col, abe, ian, hal, gav, dan, bob, ed};            eve.Prefs  = new List<Person>() {jon, hal, fred, dan, abe, gav, col, ed, ian, bob};            fay.Prefs  = new List<Person>() {bob, abe, ed, ian, jon, dan, fred, gav, col, hal};            gay.Prefs  = new List<Person>() {jon, gav, hal, fred, bob, abe, col, ed, dan, ian};            hope.Prefs = new List<Person>() {gav, jon, bob, abe, ian, dan, hal, ed, col, fred};            ivy.Prefs  = new List<Person>() {ian, col, hal, gav, fred, bob, abe, ed, jon, dan};            jan.Prefs  = new List<Person>() {ed, hal, gav, abe, bob, jon, col, ian, fred, dan};             List<Person> men = new List<Person>(abi.Prefs);             int freeMenCount = men.Count;            while (freeMenCount > 0) {                foreach (Person guy in men) {                    if (guy.Fiance == null) {                        Person gal = guy.NextCandidateNotYetProposedTo();                        if (gal.Fiance == null) {                            guy.EngageTo(gal);                            freeMenCount--;                        } else if (gal.Prefers(guy)) {                            guy.EngageTo(gal);                        }                    }                }            }             foreach (Person guy in men) {                Console.WriteLine(""{0} is engaged to {1}"", guy.Name, guy.Fiance.Name);            }            Console.WriteLine(""Stable = {0}"", IsStable(men));             Console.WriteLine(""\nSwitching fred & jon's partners"");            Person jonsFiance = jon.Fiance;            Person fredsFiance = fred.Fiance;            fred.EngageTo(jonsFiance);            jon.EngageTo(fredsFiance);            Console.WriteLine(""Stable = {0}"", IsStable(men));        }         public static void Main(string[] args)        {            DoMarriage();        }    }}"," ;; 1)(define \a (first (string->unicode ""a"")))(for/list ((i 25)) (unicode->string (+ i \a)))    → (a b c d e f g h i j k l m n o p q r s t u v w x y) ;;2) using a sequence(lib 'sequences) (take [""a"" .. ""z""] 26)    → (a b c d e f g h i j k l m n o p q r s t u v w x y z) ; or(for/string ((letter [""a"" .. ""z""])) letter)    → abcdefghijklmnopqrstuvwxyz ","(function (cFrom, cTo) {   function cRange(cFrom, cTo) {    var iStart = cFrom.charCodeAt(0);     return Array.apply(      null, Array(cTo.charCodeAt(0) - iStart + 1)    ).map(function (_, i) {       return String.fromCharCode(iStart + i);     });  }   return cRange(cFrom, cTo); })('a', 'z');","<?php$db = new SQLite3(':memory:');$db->exec(""    CREATE TABLE address (        addrID     INTEGER PRIMARY KEY AUTOINCREMENT,        addrStreet TEXT NOT NULL,        addrCity   TEXT NOT NULL,        addrState  TEXT NOT NULL,        addrZIP    TEXT NOT NULL    )"");?>","let solutions n =   let show board =    let pr v =      for i = 1 to n do        print_string (if i=v then "" q"" else "" _"");      done;      print_newline() in    List.iter pr board;    print_newline() in   let rec safe i j k = function    | [] -> true    | h::t -> h<>i && h<>j && h<>k && safe i (j+1) (k-1) t in   let rec loop col p =    for i = 1 to n    do      if safe i (i+1) (i-1) p then        let p' = i::p in        if col = n then show p'        else loop (col+1) p'    done in   loop 1 [] in let n =  if Array.length Sys.argv > 1  then int_of_string Sys.argv.(1)  else 8 in solutions n","long long fibb(long long a, long long b, int n) {    return (--n>0)?(fibb(b, a+b, n)):(a);}","// Fibonacci using BigInt with Stream.foldLeft optimized for GC (Scala v2.9 and above)// Does not run out of memory for very large Fibonacci numbers def fib(n:Int) = {   def series(i:BigInt,j:BigInt):Stream[BigInt] = i #:: series(j, i+j)   series(1,0).take(n).foldLeft(BigInt(""0""))(_+_)} // Small test(0 to 13) foreach {n => print(fib(n).toString + "" "")} // result: 0 1 1 2 3 5 8 13 21 34 55 89 144 233  ",user> (take 10 fib)(0 1 1 2 3 5 8 13 21 34),"(defun fib (n &optional (a 1) (b 0) (p 0) (q 1))    (if (= n 1) (+ (* b p) (* a q))     (fib (ash n -1)           (if (evenp n) a (+ (* b q) (* a (+ p q))))          (if (evenp n) b (+ (* b p) (* a q)))          (+ (* p p) (* q q))          (+ (* q q) (* 2 p q))))) ;p is Fib(2^n-1), q is Fib(2^n). (print (fib 100000))","#! /usr/bin/perl use strict;use Image::Imlib2; my $img = Image::Imlib2->load(""Unfilledcirc.jpg"");$img->set_color(0, 255, 0, 255);$img->fill(100,100);$img->save(""filledcirc.jpg"");exit 0;",fib = 0 : scanl (+) 1 fib," def prevPowTwo(n):    'Gets the power of two that is less than or equal to the given input'    if ((n & -n) == n):        return n    else:        n -= 1        n |= n >> 1        n |= n >> 2        n |= n >> 4        n |= n >> 8        n |= n >> 16        n += 1        return (n/2) def crazyFib(n):    'Crazy fast fibonacci number calculation'    powTwo = prevPowTwo(n)     q = r = i = 1    s = 0     while(i < powTwo):        i *= 2        q, r, s = q*q + r*r, r * (q + s), (r*r + s*s)     while(i < n):        i += 1        q, r, s = q+r, q, r     return q "
"public class Approx {    private double value;    private double error;     public Approx(){this.value = this.error = 0;}     public Approx(Approx b){        this.value = b.value;        this.error = b.error;    }     public Approx(double value, double error){        this.value = value;        this.error = error;    }     public Approx add(Approx b){        value+= b.value;        error = Math.sqrt(error * error + b.error * b.error);        return this;    }     public Approx add(double b){        value+= b;        return this;    }     public Approx sub(Approx b){        value-= b.value;        error = Math.sqrt(error * error + b.error * b.error);        return this;    }     public Approx sub(double b){        value-= b;        return this;    }     public Approx mult(Approx b){        double oldVal = value;        value*= b.value;        error = Math.sqrt(value * value * (error*error) / (oldVal*oldVal) +                                  (b.error*b.error) / (b.value*b.value));        return this;    }     public Approx mult(double b){        value*= b;        error = Math.abs(b * error);        return this;    }     public Approx div(Approx b){        double oldVal = value;        value/= b.value;        error = Math.sqrt(value * value * (error*error) / (oldVal*oldVal) +                                  (b.error*b.error) / (b.value*b.value));        return this;    }     public Approx div(double b){        value/= b;        error = Math.abs(b * error);        return this;    }     public Approx pow(double b){        double oldVal = value;        value = Math.pow(value, b);        error = Math.abs(value * b * (error / oldVal));        return this;    }     @Override    public String toString(){return value+""±""+error;}     public static void main(String[] args){        Approx x1 = new Approx(100, 1.1);        Approx x2 = new Approx(50, 1.2);        Approx y1 = new Approx(200, 2.2);        Approx y2 = new Approx(100, 2.3);         x1.sub(x2).pow(2).add(y1.sub(y2).pow(2)).pow(0.5);         System.out.println(x1);    }}","def fib(n, sequence=[1])  return sequence.last if n == 0   current_number, last_number = sequence.last(2)  sequence << current_number + (last_number or 0)   fib(n-1, sequence)end ","using System;using System.Collections.Generic;using System.Linq;using System.Text; namespace NQueens{    class Program    {        const int N = 8;         static bool Allowed(bool[,] board, int x, int y)        {            for (int i=0; i<=x; i++)            {                if (board[i,y] || (i <= y && board[x-i,y-i]) || (y+i < N && board[x-i,y+i]))                {                    return false;                }            }            return true;        }         static bool FindSolution(bool[,] board, int x)        {            for (int y = 0; y < N; y++)            {                if (Allowed(board, x, y))                {                    board[x, y] = true;                    if (x == N-1 || FindSolution(board, x + 1))                    {                        return true;                    }                    board[x, y] = false;                }            }            return false;        }         static void Main(string[] args)        {            bool[,] board = new bool[N, N];             if (FindSolution(board, 0))            {                for (int i = 0; i < N; i++)                {                    for (int j = 0; j < N; j++)                    {                        Console.Write(board[i, j] ? ""|Q"" : ""| "");                    }                    Console.WriteLine(""|"");                }            }            else            {                Console.WriteLine(""No solution found for n = "" + N + ""."");            }             Console.ReadKey(true);        }    }}",(map integer->char (iota 26 (char->integer #\a))),"[""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""q"", ""r"", ""s"", ""t"", ""u"", ""v"", ""w"", ""x"", ""y"", ""z""]","function isHappy($n) {    while (1) {        $total = 0;        while ($n > 0) {            $total += pow(($n % 10), 2);            $n /= 10;        }        if ($total == 1)            return true;        if (array_key_exists($total, $past))            return false;        $n = $total;        $past[$total] = 0;    }} $i = $cnt = 0;while ($cnt < 8) {    if (isHappy($i)) {        echo ""$i "";        $cnt++;    }    $i++;}","String.length ""Hello world"" ;;","long long int fibb(int n) {	int fnow = 0, fnext = 1, tempf;	while(--n>0){		tempf = fnow + fnext;		fnow = fnext;		fnext = tempf;		}		return fnext;	}","val it = Iterator.iterate((0,1)){case (a,b) => (b,a+b)}.map(_._1)//example:println(it.take(13).mkString("","")) //prints: 0,1,1,2,3,5,8,13,21,34,55,89,144",";; max is which fib number you'd like computed (0th, 1st, 2nd, etc.);; n is which fib number you're on for this call (0th, 1st, 2nd, etc.);; j is the nth fib number (ex. when n = 5, j = 5);; i is the nth - 1 fib number(defn- fib-iter  [max n i j]  (if (= n max)    j    (recur max           (inc n)           j           (+ i j)))) (defn fib  [max]  (if (< max 2)    max    (fib-iter max 1 0N 1N)))",(defn int fib (int n) (return (? (< n 2) n (+ (fib (- n 1)) (fib (- n 2))))))(main (prn (fib 30))),"use strict;use Image::Imlib2; sub colordistance{    my ( $c1, $c2 ) = @_;     my ( $r1, $g1, $b1 ) = @$c1;    my ( $r2, $g2, $b2 ) = @$c2;    return sqrt(( ($r1-$r2)**2 + ($g1-$g2)**2 + ($b1-$b2)**2 ))/(255.0*sqrt(3.0));} sub floodfill{    my ( $img, $x, $y, $r, $g, $b ) = @_;    my $distparameter = 0.2;     my %visited = ();    my @queue = ();     my @tcol = ( $r, $g, $b );    my @col = $img->query_pixel($x, $y);    if ( colordistance(\@tcol, \@col) > $distparameter ) { return; }    push @queue, [$x, $y];    while ( @queue ) {	my $pointref = shift(@queue);	( $x, $y ) = @$pointref;	if ( ($x < 0) || ($y < 0) || ( $x >= $img->width ) || ( $y >= $img->height ) ) { next; }	if ( ! exists($visited{""$x,$y""}) ) {	    @col = $img->query_pixel($x, $y);	    if ( colordistance(\@tcol, \@col) <= $distparameter ) {		$img->draw_point($x, $y);		$visited{""$x,$y""} = 1;		push @queue, [$x+1, $y];		push @queue, [$x-1, $y];		push @queue, [$x, $y+1];		push @queue, [$x, $y-1];	    }	}    }} # usage examplemy $img = Image::Imlib2->load(""Unfilledcirc.jpg"");$img->set_color(0,255,0,255);floodfill($img, 100,100, 0, 0, 0);$img->save(""filledcirc1.jpg"");exit 0;","import Data.List xs <+> ys = zipWith (+) xs ysxs <*> ys = sum $ zipWith (*) xs ys newtype Mat a = Mat {unMat :: [[a]]} deriving Eq instance Show a => Show (Mat a) where  show xm = ""Mat "" ++ show (unMat xm) instance Num a => Num (Mat a) where  negate xm = Mat $ map (map negate) $ unMat xm  xm + ym   = Mat $ zipWith (<+>) (unMat xm) (unMat ym)  xm * ym   = Mat [[xs <*> ys | ys <- transpose $ unMat ym] | xs <- unMat xm]  fromInteger n = Mat [[fromInteger n]]","def fib(n, c={0:1, 1:1}):    if n not in c:        x = n // 2        c[n] = fib(x-1) * fib(n-x-1) + fib(x) * fib(n - x)    return c[n] fib(10000000)  # calculating it takes a few seconds, printing it takes eons"
"public class NQueens {   private static int[] b = new int[8];  private static int s = 0;   static boolean unsafe(int y) {    int x = b[y];    for (int i = 1; i <= y; i++) {      int t = b[y - i];      if (t == x ||          t == x - i ||          t == x + i) {        return true;      }    }     return false;  }   public static void putboard() {    System.out.println(""\n\nSolution "" + (++s));    for (int y = 0; y < 8; y++) {      for (int x = 0; x < 8; x++) {        System.out.print((b[y] == x) ? ""|Q"" : ""|_"");      }      System.out.println(""|"");    }  }   public static void main(String[] args) {    int y = 0;    b[0] = -1;    while (y >= 0) {      do {        b[y]++;      } while ((b[y] < 8) && unsafe(y));      if (b[y] < 8) {        if (y < 7) {          b[++y] = -1;        } else {          putboard();        }      } else {        y--;      }    }  }}","# Use the Hash#default_proc feature to# lazily calculate the Fibonacci numbers. fib = Hash.new do |f, n|  f[n] = if n <= -2           (-1)**(n + 1) * f[n.abs]         elsif n <= 1           n.abs         else           f[n - 1] + f[n - 2]         endend# examples: fib[10] => 55, fib[-10] => (-55/1)"," using System;using System.Collections.Generic;using System.Drawing; namespace FloodFill{    class Program    {        private static bool ColorMatch(Color a, Color b)        {            return (a.ToArgb() & 0xffffff) == (b.ToArgb() & 0xffffff);        }         static void FloodFill(Bitmap bmp, Point pt, Color targetColor, Color replacementColor)        {            Queue<Point> q = new Queue<Point>();            q.Enqueue(pt);            while (q.Count > 0)            {                Point n = q.Dequeue();                if (!ColorMatch(bmp.GetPixel(n.X, n.Y),targetColor))                    continue;                Point w = n, e = new Point(n.X + 1, n.Y);                while ((w.X >= 0) && ColorMatch(bmp.GetPixel(w.X, w.Y),targetColor))                {                    bmp.SetPixel(w.X, w.Y, replacementColor);                    if ((w.Y > 0) && ColorMatch(bmp.GetPixel(w.X, w.Y - 1),targetColor))                        q.Enqueue(new Point(w.X, w.Y - 1));                    if ((w.Y < bmp.Height - 1) && ColorMatch(bmp.GetPixel(w.X, w.Y + 1),targetColor))                        q.Enqueue(new Point(w.X, w.Y + 1));                    w.X--;                }                while ((e.X <= bmp.Width - 1) && ColorMatch(bmp.GetPixel(e.X, e.Y),targetColor))                {                    bmp.SetPixel(e.X, e.Y, replacementColor);                    if ((e.Y > 0) && ColorMatch(bmp.GetPixel(e.X, e.Y - 1), targetColor))                        q.Enqueue(new Point(e.X, e.Y - 1));                    if ((e.Y < bmp.Height - 1) && ColorMatch(bmp.GetPixel(e.X, e.Y + 1), targetColor))                        q.Enqueue(new Point(e.X, e.Y + 1));                    e.X++;                }            }        }         static void Main(string[] args)        {            Bitmap bmp = new Bitmap(""Unfilledcirc.bmp"");            FloodFill(bmp, new Point(200, 200), Color.White, Color.Red);            FloodFill(bmp, new Point(100, 100), Color.Black, Color.Blue);            bmp.Save(""Filledcirc.bmp"");        }    }} ","(string-size ""Hello world"")","(function (lstRanges) {   function cRange(cFrom, cTo) {    var iStart = cFrom.codePointAt(0);     return Array.apply(      null, Array(cTo.codePointAt(0) - iStart + 1)    ).map(function (_, i) {       return String.fromCodePoint(iStart + i);     });  }   return lstRanges.map(function (lst) {    return cRange(lst[0], lst[1]);  }); })([  ['a', 'z'],  ['🐐', '🐟']]);",strrev($string);,"String.length ""møøse""UTF8.length ""møøse""","#include <tgmath.h>#define PHI ((1 + sqrt(5))/2) long long unsigned fib(unsigned n) {    return floor( (pow(PHI, n) - pow(1 - PHI, n))/sqrt(5) );}","import java.util.* class People(val map: Map<String, Array<String>>) {    operator fun get(name: String) = map[name]     val names: List<String> by lazy { map.keys.toList() }     fun preferences(k: String, v: String): List<String> {        val prefers = get(k)!!        return ArrayList<String>(prefers.slice(0..prefers.indexOf(v)))    }} class EngagementRegistry() : TreeMap<String, String>() {    constructor(guys: People, girls: People) : this() {        val freeGuys = guys.names.toMutableList()        while (freeGuys.any()) {            val guy = freeGuys.removeAt(0) // get a load of THIS guy            val guy_p = guys[guy]!!            for (girl in guy_p)                if (this[girl] == null) {                    this[girl] = guy  // girl is free                    break                } else {                    val other = this[girl]!!                    val girl_p = girls[girl]!!                    if (girl_p.indexOf(guy) < girl_p.indexOf(other)) {                        this[girl] = guy // this girl prefers this guy to the guy she's engaged to                        freeGuys += other                        break                    } // else no change... keep looking for this guy                }        }    }     override fun toString(): String {        val s = StringBuilder()        for ((k, v) in this) s.append(""$k is engaged to $v\n"")        return s.toString()    }     fun analyse(guys: People, girls: People) {        if (check(guys, girls))            println(""Marriages are stable"")        else            println(""Marriages are unstable"")    }     fun swap(girls: People, i: Int, j: Int) {        val n1 = girls.names[i]        val n2 = girls.names[j]        val g0 = this[n1]!!        val g1 = this[n2]!!        this[n1] = g1        this[n2] = g0        println(""$n1 and $n2 have switched partners"")    }     private fun check(guys: People, girls: People): Boolean {        val guy_names = guys.names        val girl_names = girls.names        if (!keys.containsAll(girl_names) or !values.containsAll(guy_names))            return false         val invertedMatches = TreeMap<String, String>()        for ((k, v) in this) invertedMatches[v] = k         for ((k, v) in this) {            val sheLikesBetter = girls.preferences(k, v)            val heLikesBetter = guys.preferences(v, k)            for (guy in sheLikesBetter) {                val fiance = invertedMatches[guy]                val guy_p = guys[guy]!!                if (guy_p.indexOf(fiance) > guy_p.indexOf(k)) {                    println(""$k likes $guy better than $v and $guy likes $k better than their current partner"")                    return false                }            }             for (girl in heLikesBetter) {                val fiance = get(girl)                val girl_p = girls[girl]!!                if (girl_p.indexOf(fiance) > girl_p.indexOf(v)) {                    println(""$v likes $girl better than $k and $girl likes $v better than their current partner"")                    return false                }            }        }        return true    }} fun main(args: Array<String>) {    val guys = People(mapOf(""abe"" to arrayOf(""abi"", ""eve"", ""cath"", ""ivy"", ""jan"", ""dee"", ""fay"", ""bea"", ""hope"", ""gay""),            ""bob"" to arrayOf(""cath"", ""hope"", ""abi"", ""dee"", ""eve"", ""fay"", ""bea"", ""jan"", ""ivy"", ""gay""),            ""col"" to arrayOf(""hope"", ""eve"", ""abi"", ""dee"", ""bea"", ""fay"", ""ivy"", ""gay"", ""cath"", ""jan""),            ""dan"" to arrayOf(""ivy"", ""fay"", ""dee"", ""gay"", ""hope"", ""eve"", ""jan"", ""bea"", ""cath"", ""abi""),            ""ed"" to arrayOf(""jan"", ""dee"", ""bea"", ""cath"", ""fay"", ""eve"", ""abi"", ""ivy"", ""hope"", ""gay""),            ""fred"" to arrayOf(""bea"", ""abi"", ""dee"", ""gay"", ""eve"", ""ivy"", ""cath"", ""jan"", ""hope"", ""fay""),            ""gav"" to arrayOf(""gay"", ""eve"", ""ivy"", ""bea"", ""cath"", ""abi"", ""dee"", ""hope"", ""jan"", ""fay""),            ""hal"" to arrayOf(""abi"", ""eve"", ""hope"", ""fay"", ""ivy"", ""cath"", ""jan"", ""bea"", ""gay"", ""dee""),            ""ian"" to arrayOf(""hope"", ""cath"", ""dee"", ""gay"", ""bea"", ""abi"", ""fay"", ""ivy"", ""jan"", ""eve""),            ""jon"" to arrayOf(""abi"", ""fay"", ""jan"", ""gay"", ""eve"", ""bea"", ""dee"", ""cath"", ""ivy"", ""hope"")))     val girls = People(mapOf(""abi"" to arrayOf(""bob"", ""fred"", ""jon"", ""gav"", ""ian"", ""abe"", ""dan"", ""ed"", ""col"", ""hal""),            ""bea"" to arrayOf(""bob"", ""abe"", ""col"", ""fred"", ""gav"", ""dan"", ""ian"", ""ed"", ""jon"", ""hal""),            ""cath"" to arrayOf(""fred"", ""bob"", ""ed"", ""gav"", ""hal"", ""col"", ""ian"", ""abe"", ""dan"", ""jon""),            ""dee"" to arrayOf(""fred"", ""jon"", ""col"", ""abe"", ""ian"", ""hal"", ""gav"", ""dan"", ""bob"", ""ed""),            ""eve"" to arrayOf(""jon"", ""hal"", ""fred"", ""dan"", ""abe"", ""gav"", ""col"", ""ed"", ""ian"", ""bob""),            ""fay"" to arrayOf(""bob"", ""abe"", ""ed"", ""ian"", ""jon"", ""dan"", ""fred"", ""gav"", ""col"", ""hal""),            ""gay"" to arrayOf(""jon"", ""gav"", ""hal"", ""fred"", ""bob"", ""abe"", ""col"", ""ed"", ""dan"", ""ian""),            ""hope"" to arrayOf(""gav"", ""jon"", ""bob"", ""abe"", ""ian"", ""dan"", ""hal"", ""ed"", ""col"", ""fred""),            ""ivy"" to arrayOf(""ian"", ""col"", ""hal"", ""gav"", ""fred"", ""bob"", ""abe"", ""ed"", ""jon"", ""dan""),            ""jan"" to arrayOf(""ed"", ""hal"", ""gav"", ""abe"", ""bob"", ""jon"", ""col"", ""ian"", ""fred"", ""dan"")))     val matches = EngagementRegistry(guys, girls)    print(matches)    matches.analyse(guys, girls)    matches.swap(girls, 0, 1)    matches.analyse(guys, girls)}",(defn fib [n]  (case n    0 0    1 1    (+ (fib (- n 1))       (fib (- n 2))))), (defun fib  ((0) 0)  ((1) 1)  ((n)    (+ (fib (- n 1))       (fib (- n 2))))) ,print 'a'..'z',"fib 0 = 0 -- this line is necessary because ""something ^ 0"" returns ""fromInteger 1"", which unfortunately          -- in our case is not our multiplicative identity (the identity matrix) but just a 1x1 matrix of 1fib n = last $ head $ unMat $ (Mat [[1,1],[1,0]]) ^ n","def fib():    """"""Yield fib[n+1] + fib[n]""""""    yield 1  # have to start somewhere    lhs, rhs = fib(), fib()    yield next(lhs) # move lhs one iteration ahead    while True:        yield next(lhs)+next(rhs) f=fib()print [next(f) for _ in range(9)]"
"import java.awt.Color;import java.awt.Point;import java.awt.image.BufferedImage;import java.util.Deque;import java.util.LinkedList; public class FloodFill {  public void floodFill(BufferedImage image, Point node, Color targetColor, Color replacementColor) {    int width = image.getWidth();    int height = image.getHeight();    int target = targetColor.getRGB();    int replacement = replacementColor.getRGB();    if (target != replacement) {      Deque<Point> queue = new LinkedList<Point>();      do {        int x = node.x;        int y = node.y;        while (x > 0 && image.getRGB(x - 1, y) == target) {          x--;        }        boolean spanUp = false;        boolean spanDown = false;        while (x < width && image.getRGB(x, y) == target) {          image.setRGB(x, y, replacement);          if (!spanUp && y > 0 && image.getRGB(x, y - 1) == target) {            queue.add(new Point(x, y - 1));            spanUp = true;          } else if (spanUp && y > 0 && image.getRGB(x, y - 1) != target) {            spanUp = false;          }          if (!spanDown && y < height - 1 && image.getRGB(x, y + 1) == target) {            queue.add(new Point(x, y + 1));            spanDown = true;          } else if (spanDown && y < height - 1 && image.getRGB(x, y + 1) != target) {            spanDown = false;          }          x++;        }      } while ((node = queue.pollFirst()) != null);    }  }}","require 'matrix' # To understand why this matrix is useful for Fibonacci numbers, remember# that the definition of Matrix.**2 for any Matrix[[a, b], [c, d]] is# is [[a*a + b*c, a*b + b*d], [c*a + d*b, c*b + d*d]].  In other words, the# lower right element is computing F(k - 2) + F(k - 1) every time M is multiplied# by itself (it is perhaps easier to understand this by computing M**2, 3, etc, and# watching the result march up the sequence of Fibonacci numbers). M = Matrix[[0, 1], [1,1]] # Matrix exponentiation algorithm to compute Fibonacci numbers.# Let M be Matrix [[0, 1], [1, 1]].  Then, the lower right element of M**k is# F(k + 1).  In other words, the lower right element of M is F(2) which is 1, and the# lower right element of M**2 is F(3) which is 2, and the lower right element# of M**3 is F(4) which is 3, etc.## This is a good way to compute F(n) because the Ruby implementation of Matrix.**(n)# uses O(log n) rather than O(n) matrix multiplications.  It works by squaring squares# ((m**2)**2)... as far as possible# and then multiplying that by by M**(the remaining number of times).  E.g., to compute# M**19, compute partial = ((M**2)**2) = M**16, and then compute partial*(M**3) = M**19.# That's only 5 matrix multiplications of M to compute M*19. def self.fib_matrix(n)  return 0 if n <= 0 # F(0)  return 1 if n == 1 # F(1)  # To get F(n >= 2), compute M**(n - 1) and extract the lower right element.  return CS::lower_right(M**(n - 1))end # Matrix utility to return# the lower, right-hand element of a given matrix.def self.lower_right matrix  return nil if matrix.row_size == 0  return matrix[matrix.row_size - 1, matrix.column_size - 1]end","namespace RosettaCode.GenerateLowerCaseASCIIAlphabet{    using System;    using System.Collections.Generic;     internal class Program    {        private static IEnumerable<char> Alphabet        {            get            {                for (var character = 'a'; character <= 'z'; character++)                {                    yield return character;                }            }        }         private static void Main()        {            Console.WriteLine(string.Join(string.Empty, Alphabet));        }    }}","(bytes-length #""Hello world"")","[[""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""q"", ""r"", ""s"", ""t"", ""u"", ""v"", ""w"", ""x"", ""y"", ""z""], [""🐐"", ""🐑"", ""🐒"", ""🐓"", ""🐔"", ""🐕"", ""🐖"", ""🐗"", ""🐘"", ""🐙"", ""🐚"", ""🐛"", ""🐜"", ""🐝"", ""🐞"", ""🐟""]]","// Will split every Unicode character to array, reverse array and will convert it to string.join('', array_reverse(preg_split('""""u', $string, -1, PREG_SPLIT_NO_EMPTY)));",(* generate next row from current row *)let next_row row =  List.map2 (+) ([0] @ row) (row @ [0]) (* returns the first n rows *)let pascal n =  let rec loop i row =    if i = n then []    else row :: loop (i+1) (next_row row)  in loop 0 [1],"#include <stdio.h>typedef enum{false=0, true=!0} bool;typedef void iterator; #include <setjmp.h>/* declare label otherwise it is not visible in sub-scope */#define LABEL(label) jmp_buf label; if(setjmp(label))goto label;#define GOTO(label) longjmp(label, true) /* the following line is the only time I have ever required ""auto"" */#define FOR(i, iterator) { auto bool lambda(i); yield_init = (void *)&lambda; iterator; bool lambda(i)#define DO {#define     YIELD(x) if(!yield(x))return#define     BREAK    return false#define     CONTINUE return true#define OD CONTINUE; } } static volatile void *yield_init; /* not thread safe */#define YIELDS(type) bool (*yield)(type) = yield_init iterator fibonacci(int stop){    YIELDS(int);    int f[] = {0, 1};    int i;    for(i=0; i<stop; i++){        YIELD(f[i%2]);        f[i%2]=f[0]+f[1];    }} main(){  printf(""fibonacci: "");  FOR(int i, fibonacci(16)) DO    printf(""%d, "",i);  OD;  printf(""...\n"");}","import java.util._import scala.collection.JavaConversions._ object SMP extends App {  def run() {    Seq(""abe"" -> Array(""abi"", ""eve"", ""cath"", ""ivy"", ""jan"", ""dee"", ""fay"", ""bea"", ""hope"", ""gay""),      ""bob"" -> Array(""cath"", ""hope"", ""abi"", ""dee"", ""eve"", ""fay"", ""bea"", ""jan"", ""ivy"", ""gay""),      ""col"" -> Array(""hope"", ""eve"", ""abi"", ""dee"", ""bea"", ""fay"", ""ivy"", ""gay"", ""cath"", ""jan""),      ""dan"" -> Array(""ivy"", ""fay"", ""dee"", ""gay"", ""hope"", ""eve"", ""jan"", ""bea"", ""cath"", ""abi""),      ""ed"" -> Array(""jan"", ""dee"", ""bea"", ""cath"", ""fay"", ""eve"", ""abi"", ""ivy"", ""hope"", ""gay""),      ""fred"" -> Array(""bea"", ""abi"", ""dee"", ""gay"", ""eve"", ""ivy"", ""cath"", ""jan"", ""hope"", ""fay""),      ""gav"" -> Array(""gay"", ""eve"", ""ivy"", ""bea"", ""cath"", ""abi"", ""dee"", ""hope"", ""jan"", ""fay""),      ""hal"" -> Array(""abi"", ""eve"", ""hope"", ""fay"", ""ivy"", ""cath"", ""jan"", ""bea"", ""gay"", ""dee""),      ""ian"" -> Array(""hope"", ""cath"", ""dee"", ""gay"", ""bea"", ""abi"", ""fay"", ""ivy"", ""jan"", ""eve""),      ""jon"" -> Array(""abi"", ""fay"", ""jan"", ""gay"", ""eve"", ""bea"", ""dee"", ""cath"", ""ivy"", ""hope""))      .foreach { e => guyPrefers.put(e._1, e._2.toList) }     Seq(""abi"" -> Array(""bob"", ""fred"", ""jon"", ""gav"", ""ian"", ""abe"", ""dan"", ""ed"", ""col"", ""hal""),      ""bea"" -> Array(""bob"", ""abe"", ""col"", ""fred"", ""gav"", ""dan"", ""ian"", ""ed"", ""jon"", ""hal""),      ""cath"" -> Array(""fred"", ""bob"", ""ed"", ""gav"", ""hal"", ""col"", ""ian"", ""abe"", ""dan"", ""jon""),      ""dee"" -> Array(""fred"", ""jon"", ""col"", ""abe"", ""ian"", ""hal"", ""gav"", ""dan"", ""bob"", ""ed""),      ""eve"" -> Array(""jon"", ""hal"", ""fred"", ""dan"", ""abe"", ""gav"", ""col"", ""ed"", ""ian"", ""bob""),      ""fay"" -> Array(""bob"", ""abe"", ""ed"", ""ian"", ""jon"", ""dan"", ""fred"", ""gav"", ""col"", ""hal""),      ""gay"" -> Array(""jon"", ""gav"", ""hal"", ""fred"", ""bob"", ""abe"", ""col"", ""ed"", ""dan"", ""ian""),      ""hope"" -> Array(""gav"", ""jon"", ""bob"", ""abe"", ""ian"", ""dan"", ""hal"", ""ed"", ""col"", ""fred""),      ""ivy"" -> Array(""ian"", ""col"", ""hal"", ""gav"", ""fred"", ""bob"", ""abe"", ""ed"", ""jon"", ""dan""),      ""jan"" -> Array(""ed"", ""hal"", ""gav"", ""abe"", ""bob"", ""jon"", ""col"", ""ian"", ""fred"", ""dan""))      .foreach { e => girlPrefers.put(e._1, e._2.toList) }     val matches = matching(guys, guyPrefers, girlPrefers)    matches.foreach { e => println(s""${e._1} is engaged to ${e._2}"") }    if (checkMatches(guys, girls, matches, guyPrefers, girlPrefers))      println(""Marriages are stable"")    else      println(""Marriages are unstable"")     val tmp = matches(girls(0))    matches += girls(0) -> matches(girls(1))    matches += girls(1) -> tmp    println(girls(0) + "" and "" + girls(1) + "" have switched partners"")    if (checkMatches(guys, girls, matches, guyPrefers, girlPrefers))      println(""Marriages are stable"")    else      println(""Marriages are unstable"")  }   private def matching(guys: Iterable[String],                       guyPrefers: Map[String, List[String]],                       girlPrefers: Map[String, List[String]]): Map[String, String] = {    val engagements = new TreeMap[String, String]    val freeGuys = new LinkedList[String](guys)    while (!freeGuys.isEmpty) {      val guy = freeGuys.remove(0)      val guy_p = guyPrefers(guy)      var break = false      for (girl <- guy_p)        if (!break)          if (!engagements.containsKey(girl)) {            engagements += girl -> guy            break = true          }          else {            val other_guy = engagements(girl)            val girl_p = girlPrefers(girl)            if (girl_p.indexOf(guy) < girl_p.indexOf(other_guy)) {              engagements += girl -> guy              freeGuys += other_guy              break = true            }          }    }     engagements  }   private def checkMatches(guys: Iterable[String], girls: Iterable[String],                           matches: Map[String, String],                           guyPrefers: Map[String, List[String]],                           girlPrefers: Map[String, List[String]]): Boolean = {    if (!matches.keySet.containsAll(girls) || !matches.values.containsAll(guys))      return false     val invertedMatches = new TreeMap[String, String]    matches.foreach { invertedMatches += _.swap }     for ((k, v) <- matches) {      val shePrefers = girlPrefers(k)      val sheLikesBetter = new LinkedList[String]      sheLikesBetter.addAll(shePrefers.subList(0, shePrefers.indexOf(v)))      val hePrefers = guyPrefers(v)      val heLikesBetter = new LinkedList[String]      heLikesBetter.addAll(hePrefers.subList(0, hePrefers.indexOf(k)))       for (guy <- sheLikesBetter) {        val fiance = invertedMatches(guy)        val guy_p = guyPrefers(guy)        if (guy_p.indexOf(fiance) > guy_p.indexOf(k)) {          println(s""$k likes $guy better than $v and $guy likes $k better than their current partner"")          return false        }      }       for (girl <- heLikesBetter) {        val fiance = matches(girl)        val girl_p = girlPrefers(girl)        if (girl_p.indexOf(fiance) > girl_p.indexOf(v)) {          println(s""$v likes $girl better than $k and $girl likes $v better than their current partner"")          return false        }      }    }    true  }   private val guys = ""abe"" :: ""bob"" :: ""col"" :: ""dan"" :: ""ed"" :: ""fred"" :: ""gav"" :: ""hal"" :: ""ian"" :: ""jon"" :: Nil  private val girls = ""abi"" :: ""bea"" :: ""cath"" :: ""dee"" :: ""eve"" :: ""fay"" :: ""gay"" :: ""hope"" :: ""ivy"" :: ""jan"" :: Nil  private val guyPrefers = new HashMap[String, List[String]]  private val girlPrefers = new HashMap[String, List[String]]   run()}",(def fib  (memoize    (fn [n]      (case n        0 0        1 1        (+ (fib (- n 1))           (fib (- n 2))))))), (defun fib  ((n) (when (>= n 0))    (fib n 0 1))) (defun fib  ((0 result _)    result)  ((n result next)    (fib (- n 1) next (+ result next))))  ,my @letters = 'a'..'z';,"fibsteps (a,b) n     | n <= 0    = (a,b)    | otherwise = fibsteps (b, a+b) (n-1) fibnums :: [Integer]fibnums = map fst $ iterate (`fibsteps` 1) (0,1)  fibN2 :: Integer -> (Integer, Integer)fibN2 m | m < 10 = fibsteps (0,1) mfibN2 m          = fibN2_next (n,r) (fibN2 n)                     where (n,r) = quotRem m 3 fibN2_next (n,r) (f,g) | r==0 = (a,b)    -- 3n  ,3n+1                       | r==1 = (b,c)    -- 3n+1,3n+2                       | r==2 = (c,d)    -- 3n+2,3n+3   (*)  where      a = ( 5*f^3 + if even n then 3*f else (- 3*f) ) -- 3n      b = (   g^3 + 3 * g * f^2 - f^3               ) -- 3n+1      c = (   g^3 + 3 * g^2 * f + f^3               ) -- 3n+2      d = ( 5*g^3 + if even n then (- 3*g) else 3*g ) -- 3(n+1)   (*) ",def (fib n)  if (n < 2)    n    (+ (fib n-1) (fib n-2))
